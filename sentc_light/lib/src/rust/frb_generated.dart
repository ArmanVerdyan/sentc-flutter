// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/group.dart';
import 'api/user.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => -1563678321;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'sentc_light_flutter',
    ioDirectory: '../../sentc_flutter_rust_light/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiUserChangePassword(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String oldPassword,
      required String newPassword,
      String? mfaToken,
      bool? mfaRecovery});

  Future<bool> crateApiUserCheckUserIdentifierAvailable(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier});

  Future<Claims> crateApiUserDecodeJwt({required String jwt});

  Future<void> crateApiUserDeleteDevice(
      {required String baseUrl,
      required String authToken,
      required String freshJwt,
      required String deviceId});

  Future<void> crateApiUserDeleteUser(
      {required String baseUrl,
      required String authToken,
      required String freshJwt});

  Future<void> crateApiUserDisableOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<String> crateApiUserDoneRegister({required String serverOutput});

  Future<void> crateApiUserDoneRegisterDeviceStart(
      {required String serverOutput});

  Future<UserDataExport> crateApiUserExtractUserData({required String data});

  Future<GeneratedRegisterData> crateApiUserGenerateUserRegisterData();

  Future<String> crateApiUserGetFreshJwt(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password,
      String? mfaToken,
      bool? mfaRecovery});

  Future<OtpRecoveryKeysOutput> crateApiUserGetOtpRecoverKeys(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<List<UserDeviceList>> crateApiUserGetUserDevices(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedId});

  Future<void> crateApiGroupGroupAcceptInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupAcceptJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      int? rank,
      required int adminRank,
      String? groupAsMember});

  Future<String> crateApiGroupGroupCreateChildGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String parentId,
      required int adminRank,
      String? groupAsMember});

  Future<String> crateApiGroupGroupCreateConnectedGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String connectedGroupId,
      required int adminRank,
      String? groupAsMember});

  Future<String> crateApiGroupGroupCreateGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      String? groupAsMember});

  Future<void> crateApiGroupGroupDeleteGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember});

  Future<void> crateApiGroupGroupDeleteSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String joinReqGroupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupDeleteSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String joinReqGroupId,
      String? groupAsMember});

  Future<GroupOutDataLightExport> crateApiGroupGroupExtractGroupData(
      {required String serverOutput});

  Future<List<GroupChildrenList>> crateApiGroupGroupGetAllFirstLevelChildren(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember});

  Future<GroupOutDataLightExport> crateApiGroupGroupGetGroupData(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<int> crateApiGroupGroupGetGroupUpdates(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<List<ListGroups>> crateApiGroupGroupGetGroupsForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId});

  Future<List<GroupInviteReqList>> crateApiGroupGroupGetInvitesForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId,
      String? groupAsMember});

  Future<List<GroupJoinReqList>> crateApiGroupGroupGetJoinReqs(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember});

  Future<List<GroupUserListItem>> crateApiGroupGroupGetMember(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember});

  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember});

  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupInviteUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      int? rank,
      required int adminRank,
      required bool autoInvite,
      required bool groupInvite,
      String? groupAsMember});

  Future<void> crateApiGroupGroupJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String groupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupKickUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int adminRank,
      String? groupAsMember});

  Future<String> crateApiGroupGroupPrepareUpdateRank(
      {required String userId, required int rank, required int adminRank});

  Future<void> crateApiGroupGroupRejectInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupRejectJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String rejectedUserId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupStopGroupInvites(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember});

  Future<void> crateApiGroupGroupUpdateRank(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int rank,
      required int adminRank,
      String? groupAsMember});

  Future<UserInitServerOutput> crateApiUserInitUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken});

  Future<void> crateApiGroupLeaveGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<UserLoginOut> crateApiUserLogin(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password});

  Future<UserDataExport> crateApiUserMfaLogin(
      {required String baseUrl,
      required String authToken,
      required String masterKeyEncryption,
      required String authKey,
      required String userIdentifier,
      required String token,
      required bool recovery});

  Future<String> crateApiUserPrepareRegister(
      {required String userIdentifier, required String password});

  Future<String> crateApiUserRefreshJwt(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken});

  Future<String> crateApiUserRegister(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password});

  Future<void> crateApiUserRegisterDevice(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String serverOutput});

  Future<String> crateApiUserRegisterDeviceStart(
      {required String baseUrl,
      required String authToken,
      required String deviceIdentifier,
      required String password});

  Future<OtpRegisterUrl> crateApiUserRegisterOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience});

  Future<OtpRegister> crateApiUserRegisterRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<OtpRegisterUrl> crateApiUserResetOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience});

  Future<OtpRegister> crateApiUserResetRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<void> crateApiUserUpdateUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String userIdentifier});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiUserChangePassword(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String oldPassword,
      required String newPassword,
      String? mfaToken,
      bool? mfaRecovery}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(oldPassword);
        var arg4 = cst_encode_String(newPassword);
        var arg5 = cst_encode_opt_String(mfaToken);
        var arg6 = cst_encode_opt_box_autoadd_bool(mfaRecovery);
        return wire.wire__crate__api__user__change_password(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserChangePasswordConstMeta,
      argValues: [
        baseUrl,
        authToken,
        userIdentifier,
        oldPassword,
        newPassword,
        mfaToken,
        mfaRecovery
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserChangePasswordConstMeta => const TaskConstMeta(
        debugName: "change_password",
        argNames: [
          "baseUrl",
          "authToken",
          "userIdentifier",
          "oldPassword",
          "newPassword",
          "mfaToken",
          "mfaRecovery"
        ],
      );

  @override
  Future<bool> crateApiUserCheckUserIdentifierAvailable(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        return wire.wire__crate__api__user__check_user_identifier_available(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserCheckUserIdentifierAvailableConstMeta,
      argValues: [baseUrl, authToken, userIdentifier],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserCheckUserIdentifierAvailableConstMeta =>
      const TaskConstMeta(
        debugName: "check_user_identifier_available",
        argNames: ["baseUrl", "authToken", "userIdentifier"],
      );

  @override
  Future<Claims> crateApiUserDecodeJwt({required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__decode_jwt(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_claims,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDecodeJwtConstMeta,
      argValues: [jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDecodeJwtConstMeta => const TaskConstMeta(
        debugName: "decode_jwt",
        argNames: ["jwt"],
      );

  @override
  Future<void> crateApiUserDeleteDevice(
      {required String baseUrl,
      required String authToken,
      required String freshJwt,
      required String deviceId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(freshJwt);
        var arg3 = cst_encode_String(deviceId);
        return wire.wire__crate__api__user__delete_device(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDeleteDeviceConstMeta,
      argValues: [baseUrl, authToken, freshJwt, deviceId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDeleteDeviceConstMeta => const TaskConstMeta(
        debugName: "delete_device",
        argNames: ["baseUrl", "authToken", "freshJwt", "deviceId"],
      );

  @override
  Future<void> crateApiUserDeleteUser(
      {required String baseUrl,
      required String authToken,
      required String freshJwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(freshJwt);
        return wire.wire__crate__api__user__delete_user(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDeleteUserConstMeta,
      argValues: [baseUrl, authToken, freshJwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDeleteUserConstMeta => const TaskConstMeta(
        debugName: "delete_user",
        argNames: ["baseUrl", "authToken", "freshJwt"],
      );

  @override
  Future<void> crateApiUserDisableOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__disable_otp(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDisableOtpConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDisableOtpConstMeta => const TaskConstMeta(
        debugName: "disable_otp",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<String> crateApiUserDoneRegister({required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__user__done_register(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDoneRegisterConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDoneRegisterConstMeta => const TaskConstMeta(
        debugName: "done_register",
        argNames: ["serverOutput"],
      );

  @override
  Future<void> crateApiUserDoneRegisterDeviceStart(
      {required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__user__done_register_device_start(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDoneRegisterDeviceStartConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDoneRegisterDeviceStartConstMeta =>
      const TaskConstMeta(
        debugName: "done_register_device_start",
        argNames: ["serverOutput"],
      );

  @override
  Future<UserDataExport> crateApiUserExtractUserData({required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(data);
        return wire.wire__crate__api__user__extract_user_data(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_data_export,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserExtractUserDataConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserExtractUserDataConstMeta =>
      const TaskConstMeta(
        debugName: "extract_user_data",
        argNames: ["data"],
      );

  @override
  Future<GeneratedRegisterData> crateApiUserGenerateUserRegisterData() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__user__generate_user_register_data(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_generated_register_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGenerateUserRegisterDataConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGenerateUserRegisterDataConstMeta =>
      const TaskConstMeta(
        debugName: "generate_user_register_data",
        argNames: [],
      );

  @override
  Future<String> crateApiUserGetFreshJwt(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password,
      String? mfaToken,
      bool? mfaRecovery}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(password);
        var arg4 = cst_encode_opt_String(mfaToken);
        var arg5 = cst_encode_opt_box_autoadd_bool(mfaRecovery);
        return wire.wire__crate__api__user__get_fresh_jwt(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGetFreshJwtConstMeta,
      argValues: [
        baseUrl,
        authToken,
        userIdentifier,
        password,
        mfaToken,
        mfaRecovery
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGetFreshJwtConstMeta => const TaskConstMeta(
        debugName: "get_fresh_jwt",
        argNames: [
          "baseUrl",
          "authToken",
          "userIdentifier",
          "password",
          "mfaToken",
          "mfaRecovery"
        ],
      );

  @override
  Future<OtpRecoveryKeysOutput> crateApiUserGetOtpRecoverKeys(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__get_otp_recover_keys(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_recovery_keys_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGetOtpRecoverKeysConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGetOtpRecoverKeysConstMeta =>
      const TaskConstMeta(
        debugName: "get_otp_recover_keys",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<List<UserDeviceList>> crateApiUserGetUserDevices(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedId);
        return wire.wire__crate__api__user__get_user_devices(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_user_device_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGetUserDevicesConstMeta,
      argValues: [baseUrl, authToken, jwt, lastFetchedTime, lastFetchedId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGetUserDevicesConstMeta => const TaskConstMeta(
        debugName: "get_user_devices",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedId"
        ],
      );

  @override
  Future<void> crateApiGroupGroupAcceptInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_accept_invite(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupAcceptInviteConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupAcceptInviteConstMeta =>
      const TaskConstMeta(
        debugName: "group_accept_invite",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupAcceptJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      int? rank,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_opt_box_autoadd_i_32(rank);
        var arg6 = cst_encode_i_32(adminRank);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_accept_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupAcceptJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        rank,
        adminRank,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupAcceptJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_accept_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "rank",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupCreateChildGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String parentId,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(parentId);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_create_child_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupCreateChildGroupConstMeta,
      argValues: [baseUrl, authToken, jwt, parentId, adminRank, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupCreateChildGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_create_child_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "parentId",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupCreateConnectedGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String connectedGroupId,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(connectedGroupId);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_create_connected_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupCreateConnectedGroupConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        connectedGroupId,
        adminRank,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupCreateConnectedGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_create_connected_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "connectedGroupId",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupCreateGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_create_group(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupCreateGroupConstMeta,
      argValues: [baseUrl, authToken, jwt, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupCreateGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_create_group",
        argNames: ["baseUrl", "authToken", "jwt", "groupAsMember"],
      );

  @override
  Future<void> crateApiGroupGroupDeleteGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_delete_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDeleteGroupConstMeta,
      argValues: [baseUrl, authToken, jwt, id, adminRank, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDeleteGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_delete_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupDeleteSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String joinReqGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(joinReqGroupId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_delete_sent_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDeleteSentJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        joinReqGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDeleteSentJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_delete_sent_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "joinReqGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupDeleteSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String joinReqGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(joinReqGroupId);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_delete_sent_join_req_user(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDeleteSentJoinReqUserConstMeta,
      argValues: [baseUrl, authToken, jwt, joinReqGroupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDeleteSentJoinReqUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_delete_sent_join_req_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "joinReqGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<GroupOutDataLightExport> crateApiGroupGroupExtractGroupData(
      {required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__group__group_extract_group_data(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_out_data_light_export,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupExtractGroupDataConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupExtractGroupDataConstMeta =>
      const TaskConstMeta(
        debugName: "group_extract_group_data",
        argNames: ["serverOutput"],
      );

  @override
  Future<List<GroupChildrenList>> crateApiGroupGroupGetAllFirstLevelChildren(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(lastFetchedTime);
        var arg5 = cst_encode_String(lastFetchedGroupId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_all_first_level_children(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_children_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetAllFirstLevelChildrenConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        lastFetchedTime,
        lastFetchedGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetAllFirstLevelChildrenConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_all_first_level_children",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<GroupOutDataLightExport> crateApiGroupGroupGetGroupData(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_group_data(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_out_data_light_export,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupDataConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupDataConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_group_data",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<int> crateApiGroupGroupGetGroupUpdates(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_group_updates(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_i_32,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupUpdatesConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupUpdatesConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_group_updates",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<List<ListGroups>> crateApiGroupGroupGetGroupsForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedGroupId);
        var arg5 = cst_encode_opt_String(groupId);
        return wire.wire__crate__api__group__group_get_groups_for_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_list_groups,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupsForUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        lastFetchedTime,
        lastFetchedGroupId,
        groupId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupsForUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_groups_for_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupId"
        ],
      );

  @override
  Future<List<GroupInviteReqList>> crateApiGroupGroupGetInvitesForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedGroupId);
        var arg5 = cst_encode_opt_String(groupId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_invites_for_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_invite_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetInvitesForUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        lastFetchedTime,
        lastFetchedGroupId,
        groupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetInvitesForUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_invites_for_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupJoinReqList>> crateApiGroupGroupGetJoinReqs(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(lastFetchedTime);
        var arg6 = cst_encode_String(lastFetchedId);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_join_reqs(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_join_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetJoinReqsConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        lastFetchedTime,
        lastFetchedId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetJoinReqsConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_join_reqs",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "lastFetchedTime",
          "lastFetchedId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupUserListItem>> crateApiGroupGroupGetMember(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(lastFetchedTime);
        var arg5 = cst_encode_String(lastFetchedId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_member(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_user_list_item,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetMemberConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        lastFetchedTime,
        lastFetchedId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetMemberConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_member",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "lastFetchedTime",
          "lastFetchedId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(lastFetchedTime);
        var arg6 = cst_encode_String(lastFetchedGroupId);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_sent_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_invite_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetSentJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        lastFetchedTime,
        lastFetchedGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetSentJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_sent_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedGroupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_sent_join_req_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_invite_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetSentJoinReqUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        lastFetchedTime,
        lastFetchedGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetSentJoinReqUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_sent_join_req_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupInviteUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      int? rank,
      required int adminRank,
      required bool autoInvite,
      required bool groupInvite,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_opt_box_autoadd_i_32(rank);
        var arg6 = cst_encode_i_32(adminRank);
        var arg7 = cst_encode_bool(autoInvite);
        var arg8 = cst_encode_bool(groupInvite);
        var arg9 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_invite_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupInviteUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        rank,
        adminRank,
        autoInvite,
        groupInvite,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupInviteUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_invite_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "rank",
          "adminRank",
          "autoInvite",
          "groupInvite",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupJoinReqConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupJoinReqConstMeta => const TaskConstMeta(
        debugName: "group_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupKickUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_i_32(adminRank);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_kick_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupKickUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        adminRank,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupKickUserConstMeta => const TaskConstMeta(
        debugName: "group_kick_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupPrepareUpdateRank(
      {required String userId, required int rank, required int adminRank}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(userId);
        var arg1 = cst_encode_i_32(rank);
        var arg2 = cst_encode_i_32(adminRank);
        return wire.wire__crate__api__group__group_prepare_update_rank(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupPrepareUpdateRankConstMeta,
      argValues: [userId, rank, adminRank],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupPrepareUpdateRankConstMeta =>
      const TaskConstMeta(
        debugName: "group_prepare_update_rank",
        argNames: ["userId", "rank", "adminRank"],
      );

  @override
  Future<void> crateApiGroupGroupRejectInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_reject_invite(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupRejectInviteConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupRejectInviteConstMeta =>
      const TaskConstMeta(
        debugName: "group_reject_invite",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupRejectJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String rejectedUserId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(rejectedUserId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_reject_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupRejectJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        rejectedUserId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupRejectJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_reject_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "rejectedUserId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupStopGroupInvites(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_stop_group_invites(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupStopGroupInvitesConstMeta,
      argValues: [baseUrl, authToken, jwt, id, adminRank, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupStopGroupInvitesConstMeta =>
      const TaskConstMeta(
        debugName: "group_stop_group_invites",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupUpdateRank(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int rank,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_i_32(rank);
        var arg6 = cst_encode_i_32(adminRank);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_update_rank(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupUpdateRankConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        rank,
        adminRank,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupUpdateRankConstMeta =>
      const TaskConstMeta(
        debugName: "group_update_rank",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "rank",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<UserInitServerOutput> crateApiUserInitUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(refreshToken);
        return wire.wire__crate__api__user__init_user(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_init_server_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserInitUserConstMeta,
      argValues: [baseUrl, authToken, jwt, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserInitUserConstMeta => const TaskConstMeta(
        debugName: "init_user",
        argNames: ["baseUrl", "authToken", "jwt", "refreshToken"],
      );

  @override
  Future<void> crateApiGroupLeaveGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__leave_group(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupLeaveGroupConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupLeaveGroupConstMeta => const TaskConstMeta(
        debugName: "leave_group",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<UserLoginOut> crateApiUserLogin(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(password);
        return wire.wire__crate__api__user__login(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_login_out,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserLoginConstMeta,
      argValues: [baseUrl, authToken, userIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserLoginConstMeta => const TaskConstMeta(
        debugName: "login",
        argNames: ["baseUrl", "authToken", "userIdentifier", "password"],
      );

  @override
  Future<UserDataExport> crateApiUserMfaLogin(
      {required String baseUrl,
      required String authToken,
      required String masterKeyEncryption,
      required String authKey,
      required String userIdentifier,
      required String token,
      required bool recovery}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(masterKeyEncryption);
        var arg3 = cst_encode_String(authKey);
        var arg4 = cst_encode_String(userIdentifier);
        var arg5 = cst_encode_String(token);
        var arg6 = cst_encode_bool(recovery);
        return wire.wire__crate__api__user__mfa_login(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_data_export,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserMfaLoginConstMeta,
      argValues: [
        baseUrl,
        authToken,
        masterKeyEncryption,
        authKey,
        userIdentifier,
        token,
        recovery
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserMfaLoginConstMeta => const TaskConstMeta(
        debugName: "mfa_login",
        argNames: [
          "baseUrl",
          "authToken",
          "masterKeyEncryption",
          "authKey",
          "userIdentifier",
          "token",
          "recovery"
        ],
      );

  @override
  Future<String> crateApiUserPrepareRegister(
      {required String userIdentifier, required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(userIdentifier);
        var arg1 = cst_encode_String(password);
        return wire.wire__crate__api__user__prepare_register(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserPrepareRegisterConstMeta,
      argValues: [userIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserPrepareRegisterConstMeta =>
      const TaskConstMeta(
        debugName: "prepare_register",
        argNames: ["userIdentifier", "password"],
      );

  @override
  Future<String> crateApiUserRefreshJwt(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(refreshToken);
        return wire.wire__crate__api__user__refresh_jwt(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRefreshJwtConstMeta,
      argValues: [baseUrl, authToken, jwt, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRefreshJwtConstMeta => const TaskConstMeta(
        debugName: "refresh_jwt",
        argNames: ["baseUrl", "authToken", "jwt", "refreshToken"],
      );

  @override
  Future<String> crateApiUserRegister(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(password);
        return wire.wire__crate__api__user__register(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterConstMeta,
      argValues: [baseUrl, authToken, userIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterConstMeta => const TaskConstMeta(
        debugName: "register",
        argNames: ["baseUrl", "authToken", "userIdentifier", "password"],
      );

  @override
  Future<void> crateApiUserRegisterDevice(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__user__register_device(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterDeviceConstMeta,
      argValues: [baseUrl, authToken, jwt, serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterDeviceConstMeta => const TaskConstMeta(
        debugName: "register_device",
        argNames: ["baseUrl", "authToken", "jwt", "serverOutput"],
      );

  @override
  Future<String> crateApiUserRegisterDeviceStart(
      {required String baseUrl,
      required String authToken,
      required String deviceIdentifier,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(deviceIdentifier);
        var arg3 = cst_encode_String(password);
        return wire.wire__crate__api__user__register_device_start(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterDeviceStartConstMeta,
      argValues: [baseUrl, authToken, deviceIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterDeviceStartConstMeta =>
      const TaskConstMeta(
        debugName: "register_device_start",
        argNames: ["baseUrl", "authToken", "deviceIdentifier", "password"],
      );

  @override
  Future<OtpRegisterUrl> crateApiUserRegisterOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(issuer);
        var arg4 = cst_encode_String(audience);
        return wire.wire__crate__api__user__register_otp(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register_url,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterOtpConstMeta,
      argValues: [baseUrl, authToken, jwt, issuer, audience],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterOtpConstMeta => const TaskConstMeta(
        debugName: "register_otp",
        argNames: ["baseUrl", "authToken", "jwt", "issuer", "audience"],
      );

  @override
  Future<OtpRegister> crateApiUserRegisterRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__register_raw_otp(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterRawOtpConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterRawOtpConstMeta => const TaskConstMeta(
        debugName: "register_raw_otp",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<OtpRegisterUrl> crateApiUserResetOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(issuer);
        var arg4 = cst_encode_String(audience);
        return wire.wire__crate__api__user__reset_otp(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register_url,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserResetOtpConstMeta,
      argValues: [baseUrl, authToken, jwt, issuer, audience],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserResetOtpConstMeta => const TaskConstMeta(
        debugName: "reset_otp",
        argNames: ["baseUrl", "authToken", "jwt", "issuer", "audience"],
      );

  @override
  Future<OtpRegister> crateApiUserResetRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__reset_raw_otp(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserResetRawOtpConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserResetRawOtpConstMeta => const TaskConstMeta(
        debugName: "reset_raw_otp",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<void> crateApiUserUpdateUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String userIdentifier}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(userIdentifier);
        return wire.wire__crate__api__user__update_user(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUpdateUserConstMeta,
      argValues: [baseUrl, authToken, jwt, userIdentifier],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUpdateUserConstMeta => const TaskConstMeta(
        debugName: "update_user",
        argNames: ["baseUrl", "authToken", "jwt", "userIdentifier"],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Claims dco_decode_claims(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Claims(
      aud: dco_decode_String(arr[0]),
      sub: dco_decode_String(arr[1]),
      exp: dco_decode_usize(arr[2]),
      iat: dco_decode_usize(arr[3]),
      fresh: dco_decode_bool(arr[4]),
    );
  }

  @protected
  DeviceKeyData dco_decode_device_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DeviceKeyData(
      privateKey: dco_decode_String(arr[0]),
      publicKey: dco_decode_String(arr[1]),
      signKey: dco_decode_String(arr[2]),
      verifyKey: dco_decode_String(arr[3]),
      exportedPublicKey: dco_decode_String(arr[4]),
      exportedVerifyKey: dco_decode_String(arr[5]),
    );
  }

  @protected
  GeneratedRegisterData dco_decode_generated_register_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GeneratedRegisterData(
      identifier: dco_decode_String(arr[0]),
      password: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupChildrenList dco_decode_group_children_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return GroupChildrenList(
      groupId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      parent: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  GroupInviteReqList dco_decode_group_invite_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GroupInviteReqList(
      groupId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupJoinReqList dco_decode_group_join_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return GroupJoinReqList(
      userId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      userType: dco_decode_i_32(arr[2]),
    );
  }

  @protected
  GroupOutDataLightExport dco_decode_group_out_data_light_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return GroupOutDataLightExport(
      groupId: dco_decode_String(arr[0]),
      parentGroupId: dco_decode_opt_String(arr[1]),
      rank: dco_decode_i_32(arr[2]),
      createdTime: dco_decode_String(arr[3]),
      joinedTime: dco_decode_String(arr[4]),
      accessByGroupAsMember: dco_decode_opt_String(arr[5]),
      accessByParentGroup: dco_decode_opt_String(arr[6]),
      isConnectedGroup: dco_decode_bool(arr[7]),
    );
  }

  @protected
  GroupUserListItem dco_decode_group_user_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GroupUserListItem(
      userId: dco_decode_String(arr[0]),
      rank: dco_decode_i_32(arr[1]),
      joinedTime: dco_decode_String(arr[2]),
      userType: dco_decode_i_32(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<GroupChildrenList> dco_decode_list_group_children_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_children_list).toList();
  }

  @protected
  List<GroupInviteReqList> dco_decode_list_group_invite_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_group_invite_req_list)
        .toList();
  }

  @protected
  List<GroupJoinReqList> dco_decode_list_group_join_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_join_req_list).toList();
  }

  @protected
  List<GroupUserListItem> dco_decode_list_group_user_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_user_list_item).toList();
  }

  @protected
  ListGroups dco_decode_list_groups(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ListGroups(
      groupId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      joinedTime: dco_decode_String(arr[2]),
      rank: dco_decode_i_32(arr[3]),
      parent: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  List<ListGroups> dco_decode_list_list_groups(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_groups).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<UserDeviceList> dco_decode_list_user_device_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_user_device_list).toList();
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  OtpRecoveryKeysOutput dco_decode_otp_recovery_keys_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OtpRecoveryKeysOutput(
      keys: dco_decode_list_String(arr[0]),
    );
  }

  @protected
  OtpRegister dco_decode_otp_register(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return OtpRegister(
      secret: dco_decode_String(arr[0]),
      alg: dco_decode_String(arr[1]),
      recover: dco_decode_list_String(arr[2]),
    );
  }

  @protected
  OtpRegisterUrl dco_decode_otp_register_url(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OtpRegisterUrl(
      url: dco_decode_String(arr[0]),
      recover: dco_decode_list_String(arr[1]),
    );
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserDataExport dco_decode_user_data_export(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return UserDataExport(
      jwt: dco_decode_String(arr[0]),
      userId: dco_decode_String(arr[1]),
      deviceId: dco_decode_String(arr[2]),
      refreshToken: dco_decode_String(arr[3]),
      deviceKeys: dco_decode_device_key_data(arr[4]),
    );
  }

  @protected
  UserDeviceList dco_decode_user_device_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UserDeviceList(
      deviceId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      deviceIdentifier: dco_decode_String(arr[2]),
    );
  }

  @protected
  UserInitServerOutput dco_decode_user_init_server_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return UserInitServerOutput(
      jwt: dco_decode_String(arr[0]),
      invites: dco_decode_list_group_invite_req_list(arr[1]),
    );
  }

  @protected
  UserLoginOut dco_decode_user_login_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UserLoginOut(
      direct: dco_decode_opt_String(arr[0]),
      masterKey: dco_decode_opt_String(arr[1]),
      authKey: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  Claims sse_decode_claims(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_aud = sse_decode_String(deserializer);
    var var_sub = sse_decode_String(deserializer);
    var var_exp = sse_decode_usize(deserializer);
    var var_iat = sse_decode_usize(deserializer);
    var var_fresh = sse_decode_bool(deserializer);
    return Claims(
        aud: var_aud,
        sub: var_sub,
        exp: var_exp,
        iat: var_iat,
        fresh: var_fresh);
  }

  @protected
  DeviceKeyData sse_decode_device_key_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKey = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    var var_signKey = sse_decode_String(deserializer);
    var var_verifyKey = sse_decode_String(deserializer);
    var var_exportedPublicKey = sse_decode_String(deserializer);
    var var_exportedVerifyKey = sse_decode_String(deserializer);
    return DeviceKeyData(
        privateKey: var_privateKey,
        publicKey: var_publicKey,
        signKey: var_signKey,
        verifyKey: var_verifyKey,
        exportedPublicKey: var_exportedPublicKey,
        exportedVerifyKey: var_exportedVerifyKey);
  }

  @protected
  GeneratedRegisterData sse_decode_generated_register_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_identifier = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    return GeneratedRegisterData(
        identifier: var_identifier, password: var_password);
  }

  @protected
  GroupChildrenList sse_decode_group_children_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_parent = sse_decode_opt_String(deserializer);
    return GroupChildrenList(
        groupId: var_groupId, time: var_time, parent: var_parent);
  }

  @protected
  GroupInviteReqList sse_decode_group_invite_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    return GroupInviteReqList(groupId: var_groupId, time: var_time);
  }

  @protected
  GroupJoinReqList sse_decode_group_join_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_userType = sse_decode_i_32(deserializer);
    return GroupJoinReqList(
        userId: var_userId, time: var_time, userType: var_userType);
  }

  @protected
  GroupOutDataLightExport sse_decode_group_out_data_light_export(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_parentGroupId = sse_decode_opt_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_createdTime = sse_decode_String(deserializer);
    var var_joinedTime = sse_decode_String(deserializer);
    var var_accessByGroupAsMember = sse_decode_opt_String(deserializer);
    var var_accessByParentGroup = sse_decode_opt_String(deserializer);
    var var_isConnectedGroup = sse_decode_bool(deserializer);
    return GroupOutDataLightExport(
        groupId: var_groupId,
        parentGroupId: var_parentGroupId,
        rank: var_rank,
        createdTime: var_createdTime,
        joinedTime: var_joinedTime,
        accessByGroupAsMember: var_accessByGroupAsMember,
        accessByParentGroup: var_accessByParentGroup,
        isConnectedGroup: var_isConnectedGroup);
  }

  @protected
  GroupUserListItem sse_decode_group_user_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_joinedTime = sse_decode_String(deserializer);
    var var_userType = sse_decode_i_32(deserializer);
    return GroupUserListItem(
        userId: var_userId,
        rank: var_rank,
        joinedTime: var_joinedTime,
        userType: var_userType);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupChildrenList> sse_decode_list_group_children_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupChildrenList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_children_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupInviteReqList> sse_decode_list_group_invite_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupInviteReqList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_invite_req_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupJoinReqList> sse_decode_list_group_join_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupJoinReqList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_join_req_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupUserListItem> sse_decode_list_group_user_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupUserListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_user_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  ListGroups sse_decode_list_groups(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_joinedTime = sse_decode_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_parent = sse_decode_opt_String(deserializer);
    return ListGroups(
        groupId: var_groupId,
        time: var_time,
        joinedTime: var_joinedTime,
        rank: var_rank,
        parent: var_parent);
  }

  @protected
  List<ListGroups> sse_decode_list_list_groups(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ListGroups>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_groups(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<UserDeviceList> sse_decode_list_user_device_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <UserDeviceList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_user_device_list(deserializer));
    }
    return ans_;
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OtpRecoveryKeysOutput sse_decode_otp_recovery_keys_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_keys = sse_decode_list_String(deserializer);
    return OtpRecoveryKeysOutput(keys: var_keys);
  }

  @protected
  OtpRegister sse_decode_otp_register(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_secret = sse_decode_String(deserializer);
    var var_alg = sse_decode_String(deserializer);
    var var_recover = sse_decode_list_String(deserializer);
    return OtpRegister(secret: var_secret, alg: var_alg, recover: var_recover);
  }

  @protected
  OtpRegisterUrl sse_decode_otp_register_url(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_recover = sse_decode_list_String(deserializer);
    return OtpRegisterUrl(url: var_url, recover: var_recover);
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserDataExport sse_decode_user_data_export(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_jwt = sse_decode_String(deserializer);
    var var_userId = sse_decode_String(deserializer);
    var var_deviceId = sse_decode_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_deviceKeys = sse_decode_device_key_data(deserializer);
    return UserDataExport(
        jwt: var_jwt,
        userId: var_userId,
        deviceId: var_deviceId,
        refreshToken: var_refreshToken,
        deviceKeys: var_deviceKeys);
  }

  @protected
  UserDeviceList sse_decode_user_device_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_deviceIdentifier = sse_decode_String(deserializer);
    return UserDeviceList(
        deviceId: var_deviceId,
        time: var_time,
        deviceIdentifier: var_deviceIdentifier);
  }

  @protected
  UserInitServerOutput sse_decode_user_init_server_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_jwt = sse_decode_String(deserializer);
    var var_invites = sse_decode_list_group_invite_req_list(deserializer);
    return UserInitServerOutput(jwt: var_jwt, invites: var_invites);
  }

  @protected
  UserLoginOut sse_decode_user_login_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_direct = sse_decode_opt_String(deserializer);
    var var_masterKey = sse_decode_opt_String(deserializer);
    var var_authKey = sse_decode_opt_String(deserializer);
    return UserLoginOut(
        direct: var_direct, masterKey: var_masterKey, authKey: var_authKey);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_claims(Claims self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.aud, serializer);
    sse_encode_String(self.sub, serializer);
    sse_encode_usize(self.exp, serializer);
    sse_encode_usize(self.iat, serializer);
    sse_encode_bool(self.fresh, serializer);
  }

  @protected
  void sse_encode_device_key_data(
      DeviceKeyData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.privateKey, serializer);
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.signKey, serializer);
    sse_encode_String(self.verifyKey, serializer);
    sse_encode_String(self.exportedPublicKey, serializer);
    sse_encode_String(self.exportedVerifyKey, serializer);
  }

  @protected
  void sse_encode_generated_register_data(
      GeneratedRegisterData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.identifier, serializer);
    sse_encode_String(self.password, serializer);
  }

  @protected
  void sse_encode_group_children_list(
      GroupChildrenList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_opt_String(self.parent, serializer);
  }

  @protected
  void sse_encode_group_invite_req_list(
      GroupInviteReqList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_String(self.time, serializer);
  }

  @protected
  void sse_encode_group_join_req_list(
      GroupJoinReqList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_i_32(self.userType, serializer);
  }

  @protected
  void sse_encode_group_out_data_light_export(
      GroupOutDataLightExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_opt_String(self.parentGroupId, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_String(self.createdTime, serializer);
    sse_encode_String(self.joinedTime, serializer);
    sse_encode_opt_String(self.accessByGroupAsMember, serializer);
    sse_encode_opt_String(self.accessByParentGroup, serializer);
    sse_encode_bool(self.isConnectedGroup, serializer);
  }

  @protected
  void sse_encode_group_user_list_item(
      GroupUserListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_String(self.joinedTime, serializer);
    sse_encode_i_32(self.userType, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_children_list(
      List<GroupChildrenList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_children_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_invite_req_list(
      List<GroupInviteReqList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_invite_req_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_join_req_list(
      List<GroupJoinReqList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_join_req_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_user_list_item(
      List<GroupUserListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_user_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_groups(ListGroups self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.joinedTime, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_opt_String(self.parent, serializer);
  }

  @protected
  void sse_encode_list_list_groups(
      List<ListGroups> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_groups(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_user_device_list(
      List<UserDeviceList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_user_device_list(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_otp_recovery_keys_output(
      OtpRecoveryKeysOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.keys, serializer);
  }

  @protected
  void sse_encode_otp_register(OtpRegister self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.secret, serializer);
    sse_encode_String(self.alg, serializer);
    sse_encode_list_String(self.recover, serializer);
  }

  @protected
  void sse_encode_otp_register_url(
      OtpRegisterUrl self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_list_String(self.recover, serializer);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_data_export(
      UserDataExport self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.jwt, serializer);
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_device_key_data(self.deviceKeys, serializer);
  }

  @protected
  void sse_encode_user_device_list(
      UserDeviceList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.deviceIdentifier, serializer);
  }

  @protected
  void sse_encode_user_init_server_output(
      UserInitServerOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.jwt, serializer);
    sse_encode_list_group_invite_req_list(self.invites, serializer);
  }

  @protected
  void sse_encode_user_login_out(UserLoginOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.direct, serializer);
    sse_encode_opt_String(self.masterKey, serializer);
    sse_encode_opt_String(self.authKey, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
