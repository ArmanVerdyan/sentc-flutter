// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`

///Create a group with a request.
///
///Only the default values are sent to the server, no extra data. If extra data is required, use prepare_create
///
Future<String> groupCreateGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupCreateGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        groupAsMember: groupAsMember);

Future<String> groupCreateChildGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String parentId,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupCreateChildGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        parentId: parentId,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<String> groupCreateConnectedGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String connectedGroupId,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupCreateConnectedGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        connectedGroupId: connectedGroupId,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

///Get the group data without a request.
///
///Use the parent group private key when fetching child group data.
///
Future<GroupOutDataLightExport> groupExtractGroupData(
        {required String serverOutput}) =>
    RustLib.instance.api
        .crateApiGroupGroupExtractGroupData(serverOutput: serverOutput);

Future<GroupOutDataLightExport> groupGetGroupData(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupData(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

Future<List<GroupUserListItem>> groupGetMember(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String lastFetchedTime,
        required String lastFetchedId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetMember(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        lastFetchedTime: lastFetchedTime,
        lastFetchedId: lastFetchedId,
        groupAsMember: groupAsMember);

Future<int> groupGetGroupUpdates(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupUpdates(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

Future<List<GroupChildrenList>> groupGetAllFirstLevelChildren(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetAllFirstLevelChildren(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupAsMember: groupAsMember);

Future<List<ListGroups>> groupGetGroupsForUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupId}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupsForUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupId: groupId);

Future<void> groupInviteUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        int? rank,
        required int adminRank,
        required bool autoInvite,
        required bool groupInvite,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupInviteUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        rank: rank,
        adminRank: adminRank,
        autoInvite: autoInvite,
        groupInvite: groupInvite,
        groupAsMember: groupAsMember);

Future<List<GroupInviteReqList>> groupGetInvitesForUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetInvitesForUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<void> groupAcceptInvite(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupAcceptInvite(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<void> groupRejectInvite(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupRejectInvite(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<List<GroupInviteReqList>> groupGetSentJoinReqUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetSentJoinReqUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupAsMember: groupAsMember);

Future<List<GroupInviteReqList>> groupGetSentJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetSentJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupAsMember: groupAsMember);

Future<void> groupDeleteSentJoinReqUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String joinReqGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupDeleteSentJoinReqUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        joinReqGroupId: joinReqGroupId,
        groupAsMember: groupAsMember);

Future<void> groupDeleteSentJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String joinReqGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupDeleteSentJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        joinReqGroupId: joinReqGroupId,
        groupAsMember: groupAsMember);

Future<void> groupJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<List<GroupJoinReqList>> groupGetJoinReqs(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String lastFetchedTime,
        required String lastFetchedId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetJoinReqs(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        lastFetchedTime: lastFetchedTime,
        lastFetchedId: lastFetchedId,
        groupAsMember: groupAsMember);

Future<void> groupRejectJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String rejectedUserId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupRejectJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        rejectedUserId: rejectedUserId,
        groupAsMember: groupAsMember);

Future<void> groupAcceptJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        int? rank,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupAcceptJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        rank: rank,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> groupStopGroupInvites(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupStopGroupInvites(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> leaveGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupLeaveGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

Future<String> groupPrepareUpdateRank(
        {required String userId, required int rank, required int adminRank}) =>
    RustLib.instance.api.crateApiGroupGroupPrepareUpdateRank(
        userId: userId, rank: rank, adminRank: adminRank);

Future<void> groupUpdateRank(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        required int rank,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupUpdateRank(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        rank: rank,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> groupKickUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupKickUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> groupDeleteGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupDeleteGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

class GroupChildrenList {
  final String groupId;
  final String time;
  final String? parent;

  const GroupChildrenList({
    required this.groupId,
    required this.time,
    this.parent,
  });

  @override
  int get hashCode => groupId.hashCode ^ time.hashCode ^ parent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupChildrenList &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          time == other.time &&
          parent == other.parent;
}

class GroupInviteReqList {
  final String groupId;
  final String time;

  const GroupInviteReqList({
    required this.groupId,
    required this.time,
  });

  @override
  int get hashCode => groupId.hashCode ^ time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupInviteReqList &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          time == other.time;
}

class GroupJoinReqList {
  final String userId;
  final String time;
  final int userType;

  const GroupJoinReqList({
    required this.userId,
    required this.time,
    required this.userType,
  });

  @override
  int get hashCode => userId.hashCode ^ time.hashCode ^ userType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupJoinReqList &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          time == other.time &&
          userType == other.userType;
}

class GroupOutDataLightExport {
  final String groupId;
  final String? parentGroupId;
  final int rank;
  final String createdTime;
  final String joinedTime;
  final String? accessByGroupAsMember;
  final String? accessByParentGroup;
  final bool isConnectedGroup;

  const GroupOutDataLightExport({
    required this.groupId,
    this.parentGroupId,
    required this.rank,
    required this.createdTime,
    required this.joinedTime,
    this.accessByGroupAsMember,
    this.accessByParentGroup,
    required this.isConnectedGroup,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      parentGroupId.hashCode ^
      rank.hashCode ^
      createdTime.hashCode ^
      joinedTime.hashCode ^
      accessByGroupAsMember.hashCode ^
      accessByParentGroup.hashCode ^
      isConnectedGroup.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupOutDataLightExport &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          parentGroupId == other.parentGroupId &&
          rank == other.rank &&
          createdTime == other.createdTime &&
          joinedTime == other.joinedTime &&
          accessByGroupAsMember == other.accessByGroupAsMember &&
          accessByParentGroup == other.accessByParentGroup &&
          isConnectedGroup == other.isConnectedGroup;
}

class GroupUserListItem {
  final String userId;
  final int rank;
  final String joinedTime;
  final int userType;

  const GroupUserListItem({
    required this.userId,
    required this.rank,
    required this.joinedTime,
    required this.userType,
  });

  @override
  int get hashCode =>
      userId.hashCode ^ rank.hashCode ^ joinedTime.hashCode ^ userType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupUserListItem &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          rank == other.rank &&
          joinedTime == other.joinedTime &&
          userType == other.userType;
}

class ListGroups {
  final String groupId;
  final String time;
  final String joinedTime;
  final int rank;
  final String? parent;

  const ListGroups({
    required this.groupId,
    required this.time,
    required this.joinedTime,
    required this.rank,
    this.parent,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      time.hashCode ^
      joinedTime.hashCode ^
      rank.hashCode ^
      parent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListGroups &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          time == other.time &&
          joinedTime == other.joinedTime &&
          rank == other.rank &&
          parent == other.parent;
}
