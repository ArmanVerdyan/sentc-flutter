// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/crypto.dart';
import 'api/file.dart';
import 'api/group.dart';
import 'api/user.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.9.0';

  @override
  int get rustContentHash => -731342369;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'sentc_flutter',
    ioDirectory: '../../sentc_flutter_rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiUserChangePassword(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String oldPassword,
      required String newPassword,
      String? mfaToken,
      bool? mfaRecovery});

  Future<bool> crateApiUserCheckUserIdentifierAvailable(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier});

  Future<SearchableCreateOutput> crateApiCryptoCreateSearchable(
      {required String key,
      required String data,
      required bool full,
      int? limit});

  Future<List<String>> crateApiCryptoCreateSearchableRaw(
      {required String key,
      required String data,
      required bool full,
      int? limit});

  Claims crateApiUserDecodeJwt({required String jwt});

  Future<Uint8List> crateApiCryptoDecryptAsymmetric(
      {required String privateKey,
      required List<int> encryptedData,
      String? verifyKeyData});

  Future<Uint8List> crateApiCryptoDecryptRawAsymmetric(
      {required String privateKey,
      required List<int> encryptedData,
      required String head,
      String? verifyKeyData});

  Future<Uint8List> crateApiCryptoDecryptRawSymmetric(
      {required String key,
      required List<int> encryptedData,
      required String head,
      String? verifyKeyData});

  Future<String> crateApiCryptoDecryptStringAsymmetric(
      {required String privateKey,
      required String encryptedData,
      String? verifyKeyData});

  Future<String> crateApiCryptoDecryptStringSymmetric(
      {required String key,
      required String encryptedData,
      String? verifyKeyData});

  Future<String> crateApiCryptoDecryptSymKey(
      {required String masterKey, required String encryptedSymmetricKeyInfo});

  Future<String> crateApiCryptoDecryptSymKeyByPrivateKey(
      {required String privateKey, required String encryptedSymmetricKeyInfo});

  Future<Uint8List> crateApiCryptoDecryptSymmetric(
      {required String key,
      required List<int> encryptedData,
      String? verifyKeyData});

  Future<void> crateApiUserDeleteDevice(
      {required String baseUrl,
      required String authToken,
      required String freshJwt,
      required String deviceId});

  Future<void> crateApiUserDeleteUser(
      {required String baseUrl,
      required String authToken,
      required String freshJwt});

  Future<EncryptedHead> crateApiCryptoDeserializeHeadFromString(
      {required String head});

  Future<void> crateApiUserDisableOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  bool crateApiUserDoneCheckUserIdentifierAvailable(
      {required String serverOutput});

  Future<String> crateApiCryptoDoneFetchSymKey(
      {required String masterKey,
      required String serverOut,
      required bool nonRegistered});

  Future<String> crateApiCryptoDoneFetchSymKeyByPrivateKey(
      {required String privateKey,
      required String serverOut,
      required bool nonRegistered});

  Future<UserKeyData> crateApiUserDoneFetchUserKey(
      {required String privateKey, required String serverOutput});

  String crateApiUserDoneRegister({required String serverOutput});

  void crateApiUserDoneRegisterDeviceStart({required String serverOutput});

  Future<Uint8List> crateApiCryptoEncryptAsymmetric(
      {required String replyPublicKeyData,
      required List<int> data,
      String? signKey});

  Future<CryptoRawOutput> crateApiCryptoEncryptRawAsymmetric(
      {required String replyPublicKeyData,
      required List<int> data,
      String? signKey});

  Future<CryptoRawOutput> crateApiCryptoEncryptRawSymmetric(
      {required String key, required List<int> data, String? signKey});

  Future<String> crateApiCryptoEncryptStringAsymmetric(
      {required String replyPublicKeyData,
      required String data,
      String? signKey});

  Future<String> crateApiCryptoEncryptStringSymmetric(
      {required String key, required String data, String? signKey});

  Future<Uint8List> crateApiCryptoEncryptSymmetric(
      {required String key, required List<int> data, String? signKey});

  Future<UserData> crateApiUserExtractUserData({required String data});

  Future<UserKeyData> crateApiUserFetchUserKey(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String keyId,
      required String privateKey});

  Future<void> crateApiFileFileDeleteFile(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String fileId,
      String? groupId,
      String? groupAsMember});

  Future<FileDoneRegister> crateApiFileFileDoneRegisterFile(
      {required String serverOutput});

  Future<FileDownloadResult> crateApiFileFileDownloadAndDecryptFilePart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String partId,
      required String contentKey,
      String? verifyKeyData});

  Future<FileDownloadResult> crateApiFileFileDownloadAndDecryptFilePartStart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String partId,
      required String contentKey,
      String? verifyKeyData});

  Future<FileData> crateApiFileFileDownloadFileMeta(
      {required String baseUrl,
      required String authToken,
      String? jwt,
      required String id,
      String? groupId,
      String? groupAsMember});

  Future<List<FilePartListItem>> crateApiFileFileDownloadPartList(
      {required String baseUrl,
      required String authToken,
      required String fileId,
      required String lastSequence});

  Future<void> crateApiFileFileFileNameUpdate(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String fileId,
      required String contentKey,
      String? fileName});

  Future<FilePrepareRegister> crateApiFileFilePrepareRegisterFile(
      {required String masterKeyId,
      required String contentKey,
      required String encryptedContentKey,
      String? belongsToId,
      required String belongsToType,
      String? fileName});

  Future<FileRegisterOutput> crateApiFileFileRegisterFile(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String masterKeyId,
      required String contentKey,
      required String encryptedContentKey,
      String? belongsToId,
      required String belongsToType,
      String? fileName,
      String? groupId,
      String? groupAsMember});

  Future<String> crateApiFileFileUploadPart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String jwt,
      required String sessionId,
      required bool end,
      required int sequence,
      required String contentKey,
      String? signKey,
      required List<int> part_});

  Future<String> crateApiFileFileUploadPartStart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String jwt,
      required String sessionId,
      required bool end,
      required int sequence,
      required String contentKey,
      String? signKey,
      required List<int> part_});

  Future<NonRegisteredKeyOutput> crateApiCryptoGenerateNonRegisterSymKey(
      {required String masterKey});

  Future<NonRegisteredKeyOutput>
      crateApiCryptoGenerateNonRegisterSymKeyByPublicKey(
          {required String replyPublicKey});

  Future<GeneratedRegisterData> crateApiUserGenerateUserRegisterData();

  Future<String> crateApiUserGetFreshJwt(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password,
      String? mfaToken,
      bool? mfaRecovery});

  Future<OtpRecoveryKeysOutput> crateApiUserGetOtpRecoverKeys(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<List<UserDeviceList>> crateApiUserGetUserDevices(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedId});

  Future<void> crateApiGroupGroupAcceptInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember});

  Future<String> crateApiGroupGroupAcceptJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int keyCount,
      int? rank,
      required int adminRank,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember});

  Future<String> crateApiGroupGroupCreateChildGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String parentPublicKey,
      required String parentId,
      required int adminRank,
      String? groupAsMember,
      String? signKey,
      required String starter});

  Future<String> crateApiGroupGroupCreateConnectedGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String connectedGroupId,
      required int adminRank,
      required String parentPublicKey,
      String? groupAsMember,
      String? signKey,
      required String starter});

  Future<String> crateApiGroupGroupCreateGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String creatorsPublicKey,
      String? groupAsMember,
      String? signKey,
      required String starter});

  Future<String> crateApiGroupGroupDecryptHmacKey(
      {required String groupKey, required String serverKeyData});

  Future<GroupKeyData> crateApiGroupGroupDecryptKey(
      {required String privateKey,
      required String serverKeyData,
      String? verifyKey});

  Future<String> crateApiGroupGroupDecryptSortableKey(
      {required String groupKey, required String serverKeyData});

  Future<void> crateApiGroupGroupDeleteGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember});

  Future<void> crateApiGroupGroupDeleteSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String joinReqGroupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupDeleteSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String joinReqGroupId,
      String? groupAsMember});

  Future<String> crateApiGroupGroupDoneKeyRotation(
      {required String privateKey,
      required String publicKey,
      required String preGroupKey,
      required String serverOutput});

  Future<GroupOutData> crateApiGroupGroupExtractGroupData(
      {required String serverOutput});

  Future<List<GroupOutDataKeys>> crateApiGroupGroupExtractGroupKeys(
      {required String serverOutput});

  Future<void> crateApiGroupGroupFinishKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String serverOutput,
      required String preGroupKey,
      required String publicKey,
      required String privateKey,
      String? groupAsMember});

  Future<List<GroupChildrenList>> crateApiGroupGroupGetAllFirstLevelChildren(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember});

  KeyRotationInput crateApiGroupGroupGetDoneKeyRotationServerInput(
      {required String serverOutput});

  Future<GroupOutData> crateApiGroupGroupGetGroupData(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<GroupOutDataKeys> crateApiGroupGroupGetGroupKey(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String keyId,
      String? groupAsMember});

  Future<List<GroupOutDataKeys>> crateApiGroupGroupGetGroupKeys(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedKeyId,
      String? groupAsMember});

  Future<GroupDataCheckUpdateServerOutput> crateApiGroupGroupGetGroupUpdates(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<List<ListGroups>> crateApiGroupGroupGetGroupsForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId});

  Future<List<GroupInviteReqList>> crateApiGroupGroupGetInvitesForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId,
      String? groupAsMember});

  Future<List<GroupJoinReqList>> crateApiGroupGroupGetJoinReqs(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember});

  Future<List<GroupUserListItem>> crateApiGroupGroupGetMember(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember});

  Future<GroupPublicKeyData> crateApiGroupGroupGetPublicKeyData(
      {required String baseUrl, required String authToken, required String id});

  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember});

  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember});

  Future<String> crateApiGroupGroupInviteUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int keyCount,
      int? rank,
      required int adminRank,
      required bool autoInvite,
      required bool groupInvite,
      required bool reInvite,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember});

  Future<void> crateApiGroupGroupInviteUserSession(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required bool autoInvite,
      required String sessionId,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember});

  Future<void> crateApiGroupGroupJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String groupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupJoinUserSession(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String sessionId,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember});

  Future<String> crateApiGroupGroupKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String publicKey,
      required String preGroupKey,
      String? signKey,
      required String starter,
      String? groupAsMember});

  Future<void> crateApiGroupGroupKickUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int adminRank,
      String? groupAsMember});

  Future<List<KeyRotationGetOut>> crateApiGroupGroupPreDoneKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<String> crateApiGroupGroupPrepareCreateGroup(
      {required String creatorsPublicKey,
      String? signKey,
      required String starter});

  Future<String> crateApiGroupGroupPrepareKeyRotation(
      {required String preGroupKey,
      required String publicKey,
      String? signKey,
      required String starter});

  Future<String> crateApiGroupGroupPrepareKeysForNewMember(
      {required String userPublicKey,
      required String groupKeys,
      required int keyCount,
      int? rank,
      required int adminRank});

  String crateApiGroupGroupPrepareUpdateRank(
      {required String userId, required int rank, required int adminRank});

  Future<void> crateApiGroupGroupRejectInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupRejectJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String rejectedUserId,
      String? groupAsMember});

  Future<void> crateApiGroupGroupStopGroupInvites(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember});

  Future<void> crateApiGroupGroupUpdateRank(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int rank,
      required int adminRank,
      String? groupAsMember});

  Future<UserInitServerOutput> crateApiUserInitUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken});

  Future<void> crateApiGroupLeaveGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember});

  Future<UserLoginOut> crateApiUserLogin(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password});

  Future<UserData> crateApiUserMfaLogin(
      {required String baseUrl,
      required String authToken,
      required String masterKeyEncryption,
      required String authKey,
      required String userIdentifier,
      required String token,
      required bool recovery});

  String crateApiUserPrepareCheckUserIdentifierAvailable(
      {required String userIdentifier});

  Future<String> crateApiUserPrepareRegister(
      {required String userIdentifier, required String password});

  Future<PreRegisterDeviceData> crateApiUserPrepareRegisterDevice(
      {required String serverOutput,
      required String userKeys,
      required int keyCount});

  Future<String> crateApiUserPrepareRegisterDeviceStart(
      {required String deviceIdentifier, required String password});

  Future<String> crateApiUserRefreshJwt(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken});

  Future<String> crateApiUserRegister(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password});

  Future<RegisterDeviceData> crateApiUserRegisterDevice(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String serverOutput,
      required int keyCount,
      required String userKeys});

  Future<String> crateApiUserRegisterDeviceStart(
      {required String baseUrl,
      required String authToken,
      required String deviceIdentifier,
      required String password});

  Future<OtpRegisterUrl> crateApiUserRegisterOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience});

  Future<OtpRegister> crateApiUserRegisterRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<OtpRegisterUrl> crateApiUserResetOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience});

  Future<void> crateApiUserResetPassword(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String newPassword,
      required String decryptedPrivateKey,
      required String decryptedSignKey});

  Future<OtpRegister> crateApiUserResetRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<String> crateApiCryptoSearch(
      {required String key, required String data});

  Future<SortableEncryptOutput> crateApiCryptoSortableEncryptNumber(
      {required String key, required BigInt data});

  Future<BigInt> crateApiCryptoSortableEncryptRawNumber(
      {required String key, required BigInt data});

  Future<BigInt> crateApiCryptoSortableEncryptRawString(
      {required String key, required String data});

  Future<SortableEncryptOutput> crateApiCryptoSortableEncryptString(
      {required String key, required String data});

  Future<EncryptedHead> crateApiCryptoSplitHeadAndEncryptedData(
      {required List<int> data});

  Future<EncryptedHead> crateApiCryptoSplitHeadAndEncryptedString(
      {required String data});

  Future<void> crateApiUserUpdateUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String userIdentifier});

  Future<String> crateApiUserUserCreateSafetyNumber(
      {required String verifyKey1,
      required String userId1,
      String? verifyKey2,
      String? userId2});

  Future<void> crateApiUserUserDeviceKeySessionUpload(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String sessionId,
      required String userPublicKey,
      required String groupKeys});

  Future<UserPublicKeyData> crateApiUserUserFetchPublicKey(
      {required String baseUrl,
      required String authToken,
      required String userId});

  Future<String> crateApiUserUserFetchVerifyKey(
      {required String baseUrl,
      required String authToken,
      required String userId,
      required String verifyKeyId});

  Future<void> crateApiUserUserFinishKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String serverOutput,
      required String preGroupKey,
      required String publicKey,
      required String privateKey});

  Future<KeyRotationInput> crateApiUserUserGetDoneKeyRotationServerInput(
      {required String serverOutput});

  Future<String> crateApiUserUserKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String publicDeviceKey,
      required String preUserKey});

  Future<List<KeyRotationGetOut>> crateApiUserUserPreDoneKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt});

  Future<bool> crateApiUserUserVerifyUserPublicKey(
      {required String verifyKey, required String publicKey});
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiUserChangePassword(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String oldPassword,
      required String newPassword,
      String? mfaToken,
      bool? mfaRecovery}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(oldPassword);
        var arg4 = cst_encode_String(newPassword);
        var arg5 = cst_encode_opt_String(mfaToken);
        var arg6 = cst_encode_opt_box_autoadd_bool(mfaRecovery);
        return wire.wire__crate__api__user__change_password(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserChangePasswordConstMeta,
      argValues: [
        baseUrl,
        authToken,
        userIdentifier,
        oldPassword,
        newPassword,
        mfaToken,
        mfaRecovery
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserChangePasswordConstMeta => const TaskConstMeta(
        debugName: "change_password",
        argNames: [
          "baseUrl",
          "authToken",
          "userIdentifier",
          "oldPassword",
          "newPassword",
          "mfaToken",
          "mfaRecovery"
        ],
      );

  @override
  Future<bool> crateApiUserCheckUserIdentifierAvailable(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        return wire.wire__crate__api__user__check_user_identifier_available(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserCheckUserIdentifierAvailableConstMeta,
      argValues: [baseUrl, authToken, userIdentifier],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserCheckUserIdentifierAvailableConstMeta =>
      const TaskConstMeta(
        debugName: "check_user_identifier_available",
        argNames: ["baseUrl", "authToken", "userIdentifier"],
      );

  @override
  Future<SearchableCreateOutput> crateApiCryptoCreateSearchable(
      {required String key,
      required String data,
      required bool full,
      int? limit}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(data);
        var arg2 = cst_encode_bool(full);
        var arg3 = cst_encode_opt_box_autoadd_u_32(limit);
        return wire.wire__crate__api__crypto__create_searchable(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_searchable_create_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoCreateSearchableConstMeta,
      argValues: [key, data, full, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoCreateSearchableConstMeta =>
      const TaskConstMeta(
        debugName: "create_searchable",
        argNames: ["key", "data", "full", "limit"],
      );

  @override
  Future<List<String>> crateApiCryptoCreateSearchableRaw(
      {required String key,
      required String data,
      required bool full,
      int? limit}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(data);
        var arg2 = cst_encode_bool(full);
        var arg3 = cst_encode_opt_box_autoadd_u_32(limit);
        return wire.wire__crate__api__crypto__create_searchable_raw(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoCreateSearchableRawConstMeta,
      argValues: [key, data, full, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoCreateSearchableRawConstMeta =>
      const TaskConstMeta(
        debugName: "create_searchable_raw",
        argNames: ["key", "data", "full", "limit"],
      );

  @override
  Claims crateApiUserDecodeJwt({required String jwt}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__decode_jwt(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_claims,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDecodeJwtConstMeta,
      argValues: [jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDecodeJwtConstMeta => const TaskConstMeta(
        debugName: "decode_jwt",
        argNames: ["jwt"],
      );

  @override
  Future<Uint8List> crateApiCryptoDecryptAsymmetric(
      {required String privateKey,
      required List<int> encryptedData,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_list_prim_u_8_loose(encryptedData);
        var arg2 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__crypto__decrypt_asymmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptAsymmetricConstMeta,
      argValues: [privateKey, encryptedData, verifyKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptAsymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_asymmetric",
        argNames: ["privateKey", "encryptedData", "verifyKeyData"],
      );

  @override
  Future<Uint8List> crateApiCryptoDecryptRawAsymmetric(
      {required String privateKey,
      required List<int> encryptedData,
      required String head,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_list_prim_u_8_loose(encryptedData);
        var arg2 = cst_encode_String(head);
        var arg3 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__crypto__decrypt_raw_asymmetric(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptRawAsymmetricConstMeta,
      argValues: [privateKey, encryptedData, head, verifyKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptRawAsymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_raw_asymmetric",
        argNames: ["privateKey", "encryptedData", "head", "verifyKeyData"],
      );

  @override
  Future<Uint8List> crateApiCryptoDecryptRawSymmetric(
      {required String key,
      required List<int> encryptedData,
      required String head,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_list_prim_u_8_loose(encryptedData);
        var arg2 = cst_encode_String(head);
        var arg3 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__crypto__decrypt_raw_symmetric(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptRawSymmetricConstMeta,
      argValues: [key, encryptedData, head, verifyKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptRawSymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_raw_symmetric",
        argNames: ["key", "encryptedData", "head", "verifyKeyData"],
      );

  @override
  Future<String> crateApiCryptoDecryptStringAsymmetric(
      {required String privateKey,
      required String encryptedData,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_String(encryptedData);
        var arg2 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__crypto__decrypt_string_asymmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptStringAsymmetricConstMeta,
      argValues: [privateKey, encryptedData, verifyKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptStringAsymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_string_asymmetric",
        argNames: ["privateKey", "encryptedData", "verifyKeyData"],
      );

  @override
  Future<String> crateApiCryptoDecryptStringSymmetric(
      {required String key,
      required String encryptedData,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(encryptedData);
        var arg2 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__crypto__decrypt_string_symmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptStringSymmetricConstMeta,
      argValues: [key, encryptedData, verifyKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptStringSymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_string_symmetric",
        argNames: ["key", "encryptedData", "verifyKeyData"],
      );

  @override
  Future<String> crateApiCryptoDecryptSymKey(
      {required String masterKey, required String encryptedSymmetricKeyInfo}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(masterKey);
        var arg1 = cst_encode_String(encryptedSymmetricKeyInfo);
        return wire.wire__crate__api__crypto__decrypt_sym_key(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptSymKeyConstMeta,
      argValues: [masterKey, encryptedSymmetricKeyInfo],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptSymKeyConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_sym_key",
        argNames: ["masterKey", "encryptedSymmetricKeyInfo"],
      );

  @override
  Future<String> crateApiCryptoDecryptSymKeyByPrivateKey(
      {required String privateKey, required String encryptedSymmetricKeyInfo}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_String(encryptedSymmetricKeyInfo);
        return wire.wire__crate__api__crypto__decrypt_sym_key_by_private_key(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptSymKeyByPrivateKeyConstMeta,
      argValues: [privateKey, encryptedSymmetricKeyInfo],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptSymKeyByPrivateKeyConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_sym_key_by_private_key",
        argNames: ["privateKey", "encryptedSymmetricKeyInfo"],
      );

  @override
  Future<Uint8List> crateApiCryptoDecryptSymmetric(
      {required String key,
      required List<int> encryptedData,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_list_prim_u_8_loose(encryptedData);
        var arg2 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__crypto__decrypt_symmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDecryptSymmetricConstMeta,
      argValues: [key, encryptedData, verifyKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDecryptSymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "decrypt_symmetric",
        argNames: ["key", "encryptedData", "verifyKeyData"],
      );

  @override
  Future<void> crateApiUserDeleteDevice(
      {required String baseUrl,
      required String authToken,
      required String freshJwt,
      required String deviceId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(freshJwt);
        var arg3 = cst_encode_String(deviceId);
        return wire.wire__crate__api__user__delete_device(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDeleteDeviceConstMeta,
      argValues: [baseUrl, authToken, freshJwt, deviceId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDeleteDeviceConstMeta => const TaskConstMeta(
        debugName: "delete_device",
        argNames: ["baseUrl", "authToken", "freshJwt", "deviceId"],
      );

  @override
  Future<void> crateApiUserDeleteUser(
      {required String baseUrl,
      required String authToken,
      required String freshJwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(freshJwt);
        return wire.wire__crate__api__user__delete_user(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDeleteUserConstMeta,
      argValues: [baseUrl, authToken, freshJwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDeleteUserConstMeta => const TaskConstMeta(
        debugName: "delete_user",
        argNames: ["baseUrl", "authToken", "freshJwt"],
      );

  @override
  Future<EncryptedHead> crateApiCryptoDeserializeHeadFromString(
      {required String head}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(head);
        return wire.wire__crate__api__crypto__deserialize_head_from_string(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_encrypted_head,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDeserializeHeadFromStringConstMeta,
      argValues: [head],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDeserializeHeadFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "deserialize_head_from_string",
        argNames: ["head"],
      );

  @override
  Future<void> crateApiUserDisableOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__disable_otp(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDisableOtpConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDisableOtpConstMeta => const TaskConstMeta(
        debugName: "disable_otp",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  bool crateApiUserDoneCheckUserIdentifierAvailable(
      {required String serverOutput}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(serverOutput);
        return wire
            .wire__crate__api__user__done_check_user_identifier_available(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDoneCheckUserIdentifierAvailableConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDoneCheckUserIdentifierAvailableConstMeta =>
      const TaskConstMeta(
        debugName: "done_check_user_identifier_available",
        argNames: ["serverOutput"],
      );

  @override
  Future<String> crateApiCryptoDoneFetchSymKey(
      {required String masterKey,
      required String serverOut,
      required bool nonRegistered}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(masterKey);
        var arg1 = cst_encode_String(serverOut);
        var arg2 = cst_encode_bool(nonRegistered);
        return wire.wire__crate__api__crypto__done_fetch_sym_key(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDoneFetchSymKeyConstMeta,
      argValues: [masterKey, serverOut, nonRegistered],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDoneFetchSymKeyConstMeta =>
      const TaskConstMeta(
        debugName: "done_fetch_sym_key",
        argNames: ["masterKey", "serverOut", "nonRegistered"],
      );

  @override
  Future<String> crateApiCryptoDoneFetchSymKeyByPrivateKey(
      {required String privateKey,
      required String serverOut,
      required bool nonRegistered}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_String(serverOut);
        var arg2 = cst_encode_bool(nonRegistered);
        return wire.wire__crate__api__crypto__done_fetch_sym_key_by_private_key(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoDoneFetchSymKeyByPrivateKeyConstMeta,
      argValues: [privateKey, serverOut, nonRegistered],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoDoneFetchSymKeyByPrivateKeyConstMeta =>
      const TaskConstMeta(
        debugName: "done_fetch_sym_key_by_private_key",
        argNames: ["privateKey", "serverOut", "nonRegistered"],
      );

  @override
  Future<UserKeyData> crateApiUserDoneFetchUserKey(
      {required String privateKey, required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__user__done_fetch_user_key(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_key_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDoneFetchUserKeyConstMeta,
      argValues: [privateKey, serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDoneFetchUserKeyConstMeta =>
      const TaskConstMeta(
        debugName: "done_fetch_user_key",
        argNames: ["privateKey", "serverOutput"],
      );

  @override
  String crateApiUserDoneRegister({required String serverOutput}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__user__done_register(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDoneRegisterConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDoneRegisterConstMeta => const TaskConstMeta(
        debugName: "done_register",
        argNames: ["serverOutput"],
      );

  @override
  void crateApiUserDoneRegisterDeviceStart({required String serverOutput}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__user__done_register_device_start(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserDoneRegisterDeviceStartConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserDoneRegisterDeviceStartConstMeta =>
      const TaskConstMeta(
        debugName: "done_register_device_start",
        argNames: ["serverOutput"],
      );

  @override
  Future<Uint8List> crateApiCryptoEncryptAsymmetric(
      {required String replyPublicKeyData,
      required List<int> data,
      String? signKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(replyPublicKeyData);
        var arg1 = cst_encode_list_prim_u_8_loose(data);
        var arg2 = cst_encode_opt_String(signKey);
        return wire.wire__crate__api__crypto__encrypt_asymmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoEncryptAsymmetricConstMeta,
      argValues: [replyPublicKeyData, data, signKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoEncryptAsymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "encrypt_asymmetric",
        argNames: ["replyPublicKeyData", "data", "signKey"],
      );

  @override
  Future<CryptoRawOutput> crateApiCryptoEncryptRawAsymmetric(
      {required String replyPublicKeyData,
      required List<int> data,
      String? signKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(replyPublicKeyData);
        var arg1 = cst_encode_list_prim_u_8_loose(data);
        var arg2 = cst_encode_opt_String(signKey);
        return wire.wire__crate__api__crypto__encrypt_raw_asymmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_crypto_raw_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoEncryptRawAsymmetricConstMeta,
      argValues: [replyPublicKeyData, data, signKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoEncryptRawAsymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "encrypt_raw_asymmetric",
        argNames: ["replyPublicKeyData", "data", "signKey"],
      );

  @override
  Future<CryptoRawOutput> crateApiCryptoEncryptRawSymmetric(
      {required String key, required List<int> data, String? signKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_list_prim_u_8_loose(data);
        var arg2 = cst_encode_opt_String(signKey);
        return wire.wire__crate__api__crypto__encrypt_raw_symmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_crypto_raw_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoEncryptRawSymmetricConstMeta,
      argValues: [key, data, signKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoEncryptRawSymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "encrypt_raw_symmetric",
        argNames: ["key", "data", "signKey"],
      );

  @override
  Future<String> crateApiCryptoEncryptStringAsymmetric(
      {required String replyPublicKeyData,
      required String data,
      String? signKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(replyPublicKeyData);
        var arg1 = cst_encode_String(data);
        var arg2 = cst_encode_opt_String(signKey);
        return wire.wire__crate__api__crypto__encrypt_string_asymmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoEncryptStringAsymmetricConstMeta,
      argValues: [replyPublicKeyData, data, signKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoEncryptStringAsymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "encrypt_string_asymmetric",
        argNames: ["replyPublicKeyData", "data", "signKey"],
      );

  @override
  Future<String> crateApiCryptoEncryptStringSymmetric(
      {required String key, required String data, String? signKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(data);
        var arg2 = cst_encode_opt_String(signKey);
        return wire.wire__crate__api__crypto__encrypt_string_symmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoEncryptStringSymmetricConstMeta,
      argValues: [key, data, signKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoEncryptStringSymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "encrypt_string_symmetric",
        argNames: ["key", "data", "signKey"],
      );

  @override
  Future<Uint8List> crateApiCryptoEncryptSymmetric(
      {required String key, required List<int> data, String? signKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_list_prim_u_8_loose(data);
        var arg2 = cst_encode_opt_String(signKey);
        return wire.wire__crate__api__crypto__encrypt_symmetric(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoEncryptSymmetricConstMeta,
      argValues: [key, data, signKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoEncryptSymmetricConstMeta =>
      const TaskConstMeta(
        debugName: "encrypt_symmetric",
        argNames: ["key", "data", "signKey"],
      );

  @override
  Future<UserData> crateApiUserExtractUserData({required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(data);
        return wire.wire__crate__api__user__extract_user_data(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserExtractUserDataConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserExtractUserDataConstMeta =>
      const TaskConstMeta(
        debugName: "extract_user_data",
        argNames: ["data"],
      );

  @override
  Future<UserKeyData> crateApiUserFetchUserKey(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String keyId,
      required String privateKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(keyId);
        var arg4 = cst_encode_String(privateKey);
        return wire.wire__crate__api__user__fetch_user_key(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_key_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserFetchUserKeyConstMeta,
      argValues: [baseUrl, authToken, jwt, keyId, privateKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserFetchUserKeyConstMeta => const TaskConstMeta(
        debugName: "fetch_user_key",
        argNames: ["baseUrl", "authToken", "jwt", "keyId", "privateKey"],
      );

  @override
  Future<void> crateApiFileFileDeleteFile(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String fileId,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(fileId);
        var arg4 = cst_encode_opt_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__file__file_delete_file(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileDeleteFileConstMeta,
      argValues: [baseUrl, authToken, jwt, fileId, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileDeleteFileConstMeta => const TaskConstMeta(
        debugName: "file_delete_file",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "fileId",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<FileDoneRegister> crateApiFileFileDoneRegisterFile(
      {required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__file__file_done_register_file(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_file_done_register,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileDoneRegisterFileConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileDoneRegisterFileConstMeta =>
      const TaskConstMeta(
        debugName: "file_done_register_file",
        argNames: ["serverOutput"],
      );

  @override
  Future<FileDownloadResult> crateApiFileFileDownloadAndDecryptFilePart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String partId,
      required String contentKey,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_opt_String(urlPrefix);
        var arg2 = cst_encode_String(authToken);
        var arg3 = cst_encode_String(partId);
        var arg4 = cst_encode_String(contentKey);
        var arg5 = cst_encode_opt_String(verifyKeyData);
        return wire.wire__crate__api__file__file_download_and_decrypt_file_part(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_file_download_result,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileDownloadAndDecryptFilePartConstMeta,
      argValues: [
        baseUrl,
        urlPrefix,
        authToken,
        partId,
        contentKey,
        verifyKeyData
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileDownloadAndDecryptFilePartConstMeta =>
      const TaskConstMeta(
        debugName: "file_download_and_decrypt_file_part",
        argNames: [
          "baseUrl",
          "urlPrefix",
          "authToken",
          "partId",
          "contentKey",
          "verifyKeyData"
        ],
      );

  @override
  Future<FileDownloadResult> crateApiFileFileDownloadAndDecryptFilePartStart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String partId,
      required String contentKey,
      String? verifyKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_opt_String(urlPrefix);
        var arg2 = cst_encode_String(authToken);
        var arg3 = cst_encode_String(partId);
        var arg4 = cst_encode_String(contentKey);
        var arg5 = cst_encode_opt_String(verifyKeyData);
        return wire
            .wire__crate__api__file__file_download_and_decrypt_file_part_start(
                port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_file_download_result,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileDownloadAndDecryptFilePartStartConstMeta,
      argValues: [
        baseUrl,
        urlPrefix,
        authToken,
        partId,
        contentKey,
        verifyKeyData
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileDownloadAndDecryptFilePartStartConstMeta =>
      const TaskConstMeta(
        debugName: "file_download_and_decrypt_file_part_start",
        argNames: [
          "baseUrl",
          "urlPrefix",
          "authToken",
          "partId",
          "contentKey",
          "verifyKeyData"
        ],
      );

  @override
  Future<FileData> crateApiFileFileDownloadFileMeta(
      {required String baseUrl,
      required String authToken,
      String? jwt,
      required String id,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_opt_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__file__file_download_file_meta(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_file_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileDownloadFileMetaConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileDownloadFileMetaConstMeta =>
      const TaskConstMeta(
        debugName: "file_download_file_meta",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<FilePartListItem>> crateApiFileFileDownloadPartList(
      {required String baseUrl,
      required String authToken,
      required String fileId,
      required String lastSequence}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(fileId);
        var arg3 = cst_encode_String(lastSequence);
        return wire.wire__crate__api__file__file_download_part_list(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_file_part_list_item,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileDownloadPartListConstMeta,
      argValues: [baseUrl, authToken, fileId, lastSequence],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileDownloadPartListConstMeta =>
      const TaskConstMeta(
        debugName: "file_download_part_list",
        argNames: ["baseUrl", "authToken", "fileId", "lastSequence"],
      );

  @override
  Future<void> crateApiFileFileFileNameUpdate(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String fileId,
      required String contentKey,
      String? fileName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(fileId);
        var arg4 = cst_encode_String(contentKey);
        var arg5 = cst_encode_opt_String(fileName);
        return wire.wire__crate__api__file__file_file_name_update(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileFileNameUpdateConstMeta,
      argValues: [baseUrl, authToken, jwt, fileId, contentKey, fileName],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileFileNameUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "file_file_name_update",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "fileId",
          "contentKey",
          "fileName"
        ],
      );

  @override
  Future<FilePrepareRegister> crateApiFileFilePrepareRegisterFile(
      {required String masterKeyId,
      required String contentKey,
      required String encryptedContentKey,
      String? belongsToId,
      required String belongsToType,
      String? fileName}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(masterKeyId);
        var arg1 = cst_encode_String(contentKey);
        var arg2 = cst_encode_String(encryptedContentKey);
        var arg3 = cst_encode_opt_String(belongsToId);
        var arg4 = cst_encode_String(belongsToType);
        var arg5 = cst_encode_opt_String(fileName);
        return wire.wire__crate__api__file__file_prepare_register_file(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_file_prepare_register,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFilePrepareRegisterFileConstMeta,
      argValues: [
        masterKeyId,
        contentKey,
        encryptedContentKey,
        belongsToId,
        belongsToType,
        fileName
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFilePrepareRegisterFileConstMeta =>
      const TaskConstMeta(
        debugName: "file_prepare_register_file",
        argNames: [
          "masterKeyId",
          "contentKey",
          "encryptedContentKey",
          "belongsToId",
          "belongsToType",
          "fileName"
        ],
      );

  @override
  Future<FileRegisterOutput> crateApiFileFileRegisterFile(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String masterKeyId,
      required String contentKey,
      required String encryptedContentKey,
      String? belongsToId,
      required String belongsToType,
      String? fileName,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(masterKeyId);
        var arg4 = cst_encode_String(contentKey);
        var arg5 = cst_encode_String(encryptedContentKey);
        var arg6 = cst_encode_opt_String(belongsToId);
        var arg7 = cst_encode_String(belongsToType);
        var arg8 = cst_encode_opt_String(fileName);
        var arg9 = cst_encode_opt_String(groupId);
        var arg10 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__file__file_register_file(port_, arg0,
            arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_file_register_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileRegisterFileConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        masterKeyId,
        contentKey,
        encryptedContentKey,
        belongsToId,
        belongsToType,
        fileName,
        groupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileRegisterFileConstMeta =>
      const TaskConstMeta(
        debugName: "file_register_file",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "masterKeyId",
          "contentKey",
          "encryptedContentKey",
          "belongsToId",
          "belongsToType",
          "fileName",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiFileFileUploadPart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String jwt,
      required String sessionId,
      required bool end,
      required int sequence,
      required String contentKey,
      String? signKey,
      required List<int> part_}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_opt_String(urlPrefix);
        var arg2 = cst_encode_String(authToken);
        var arg3 = cst_encode_String(jwt);
        var arg4 = cst_encode_String(sessionId);
        var arg5 = cst_encode_bool(end);
        var arg6 = cst_encode_i_32(sequence);
        var arg7 = cst_encode_String(contentKey);
        var arg8 = cst_encode_opt_String(signKey);
        var arg9 = cst_encode_list_prim_u_8_loose(part_);
        return wire.wire__crate__api__file__file_upload_part(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileUploadPartConstMeta,
      argValues: [
        baseUrl,
        urlPrefix,
        authToken,
        jwt,
        sessionId,
        end,
        sequence,
        contentKey,
        signKey,
        part_
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileUploadPartConstMeta => const TaskConstMeta(
        debugName: "file_upload_part",
        argNames: [
          "baseUrl",
          "urlPrefix",
          "authToken",
          "jwt",
          "sessionId",
          "end",
          "sequence",
          "contentKey",
          "signKey",
          "part_"
        ],
      );

  @override
  Future<String> crateApiFileFileUploadPartStart(
      {required String baseUrl,
      String? urlPrefix,
      required String authToken,
      required String jwt,
      required String sessionId,
      required bool end,
      required int sequence,
      required String contentKey,
      String? signKey,
      required List<int> part_}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_opt_String(urlPrefix);
        var arg2 = cst_encode_String(authToken);
        var arg3 = cst_encode_String(jwt);
        var arg4 = cst_encode_String(sessionId);
        var arg5 = cst_encode_bool(end);
        var arg6 = cst_encode_i_32(sequence);
        var arg7 = cst_encode_String(contentKey);
        var arg8 = cst_encode_opt_String(signKey);
        var arg9 = cst_encode_list_prim_u_8_loose(part_);
        return wire.wire__crate__api__file__file_upload_part_start(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiFileFileUploadPartStartConstMeta,
      argValues: [
        baseUrl,
        urlPrefix,
        authToken,
        jwt,
        sessionId,
        end,
        sequence,
        contentKey,
        signKey,
        part_
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFileFileUploadPartStartConstMeta =>
      const TaskConstMeta(
        debugName: "file_upload_part_start",
        argNames: [
          "baseUrl",
          "urlPrefix",
          "authToken",
          "jwt",
          "sessionId",
          "end",
          "sequence",
          "contentKey",
          "signKey",
          "part_"
        ],
      );

  @override
  Future<NonRegisteredKeyOutput> crateApiCryptoGenerateNonRegisterSymKey(
      {required String masterKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(masterKey);
        return wire.wire__crate__api__crypto__generate_non_register_sym_key(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_non_registered_key_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoGenerateNonRegisterSymKeyConstMeta,
      argValues: [masterKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoGenerateNonRegisterSymKeyConstMeta =>
      const TaskConstMeta(
        debugName: "generate_non_register_sym_key",
        argNames: ["masterKey"],
      );

  @override
  Future<NonRegisteredKeyOutput>
      crateApiCryptoGenerateNonRegisterSymKeyByPublicKey(
          {required String replyPublicKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(replyPublicKey);
        return wire
            .wire__crate__api__crypto__generate_non_register_sym_key_by_public_key(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_non_registered_key_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoGenerateNonRegisterSymKeyByPublicKeyConstMeta,
      argValues: [replyPublicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiCryptoGenerateNonRegisterSymKeyByPublicKeyConstMeta =>
          const TaskConstMeta(
            debugName: "generate_non_register_sym_key_by_public_key",
            argNames: ["replyPublicKey"],
          );

  @override
  Future<GeneratedRegisterData> crateApiUserGenerateUserRegisterData() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__user__generate_user_register_data(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_generated_register_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGenerateUserRegisterDataConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGenerateUserRegisterDataConstMeta =>
      const TaskConstMeta(
        debugName: "generate_user_register_data",
        argNames: [],
      );

  @override
  Future<String> crateApiUserGetFreshJwt(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password,
      String? mfaToken,
      bool? mfaRecovery}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(password);
        var arg4 = cst_encode_opt_String(mfaToken);
        var arg5 = cst_encode_opt_box_autoadd_bool(mfaRecovery);
        return wire.wire__crate__api__user__get_fresh_jwt(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGetFreshJwtConstMeta,
      argValues: [
        baseUrl,
        authToken,
        userIdentifier,
        password,
        mfaToken,
        mfaRecovery
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGetFreshJwtConstMeta => const TaskConstMeta(
        debugName: "get_fresh_jwt",
        argNames: [
          "baseUrl",
          "authToken",
          "userIdentifier",
          "password",
          "mfaToken",
          "mfaRecovery"
        ],
      );

  @override
  Future<OtpRecoveryKeysOutput> crateApiUserGetOtpRecoverKeys(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__get_otp_recover_keys(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_recovery_keys_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGetOtpRecoverKeysConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGetOtpRecoverKeysConstMeta =>
      const TaskConstMeta(
        debugName: "get_otp_recover_keys",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<List<UserDeviceList>> crateApiUserGetUserDevices(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedId);
        return wire.wire__crate__api__user__get_user_devices(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_user_device_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserGetUserDevicesConstMeta,
      argValues: [baseUrl, authToken, jwt, lastFetchedTime, lastFetchedId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserGetUserDevicesConstMeta => const TaskConstMeta(
        debugName: "get_user_devices",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedId"
        ],
      );

  @override
  Future<void> crateApiGroupGroupAcceptInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_accept_invite(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupAcceptInviteConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupAcceptInviteConstMeta =>
      const TaskConstMeta(
        debugName: "group_accept_invite",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupAcceptJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int keyCount,
      int? rank,
      required int adminRank,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_i_32(keyCount);
        var arg6 = cst_encode_opt_box_autoadd_i_32(rank);
        var arg7 = cst_encode_i_32(adminRank);
        var arg8 = cst_encode_String(userPublicKey);
        var arg9 = cst_encode_String(groupKeys);
        var arg10 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_accept_join_req(port_, arg0,
            arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupAcceptJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        keyCount,
        rank,
        adminRank,
        userPublicKey,
        groupKeys,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupAcceptJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_accept_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "keyCount",
          "rank",
          "adminRank",
          "userPublicKey",
          "groupKeys",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupCreateChildGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String parentPublicKey,
      required String parentId,
      required int adminRank,
      String? groupAsMember,
      String? signKey,
      required String starter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(parentPublicKey);
        var arg4 = cst_encode_String(parentId);
        var arg5 = cst_encode_i_32(adminRank);
        var arg6 = cst_encode_opt_String(groupAsMember);
        var arg7 = cst_encode_opt_String(signKey);
        var arg8 = cst_encode_String(starter);
        return wire.wire__crate__api__group__group_create_child_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupCreateChildGroupConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        parentPublicKey,
        parentId,
        adminRank,
        groupAsMember,
        signKey,
        starter
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupCreateChildGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_create_child_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "parentPublicKey",
          "parentId",
          "adminRank",
          "groupAsMember",
          "signKey",
          "starter"
        ],
      );

  @override
  Future<String> crateApiGroupGroupCreateConnectedGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String connectedGroupId,
      required int adminRank,
      required String parentPublicKey,
      String? groupAsMember,
      String? signKey,
      required String starter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(connectedGroupId);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(parentPublicKey);
        var arg6 = cst_encode_opt_String(groupAsMember);
        var arg7 = cst_encode_opt_String(signKey);
        var arg8 = cst_encode_String(starter);
        return wire.wire__crate__api__group__group_create_connected_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupCreateConnectedGroupConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        connectedGroupId,
        adminRank,
        parentPublicKey,
        groupAsMember,
        signKey,
        starter
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupCreateConnectedGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_create_connected_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "connectedGroupId",
          "adminRank",
          "parentPublicKey",
          "groupAsMember",
          "signKey",
          "starter"
        ],
      );

  @override
  Future<String> crateApiGroupGroupCreateGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String creatorsPublicKey,
      String? groupAsMember,
      String? signKey,
      required String starter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(creatorsPublicKey);
        var arg4 = cst_encode_opt_String(groupAsMember);
        var arg5 = cst_encode_opt_String(signKey);
        var arg6 = cst_encode_String(starter);
        return wire.wire__crate__api__group__group_create_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupCreateGroupConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        creatorsPublicKey,
        groupAsMember,
        signKey,
        starter
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupCreateGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_create_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "creatorsPublicKey",
          "groupAsMember",
          "signKey",
          "starter"
        ],
      );

  @override
  Future<String> crateApiGroupGroupDecryptHmacKey(
      {required String groupKey, required String serverKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(groupKey);
        var arg1 = cst_encode_String(serverKeyData);
        return wire.wire__crate__api__group__group_decrypt_hmac_key(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDecryptHmacKeyConstMeta,
      argValues: [groupKey, serverKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDecryptHmacKeyConstMeta =>
      const TaskConstMeta(
        debugName: "group_decrypt_hmac_key",
        argNames: ["groupKey", "serverKeyData"],
      );

  @override
  Future<GroupKeyData> crateApiGroupGroupDecryptKey(
      {required String privateKey,
      required String serverKeyData,
      String? verifyKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_String(serverKeyData);
        var arg2 = cst_encode_opt_String(verifyKey);
        return wire.wire__crate__api__group__group_decrypt_key(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_key_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDecryptKeyConstMeta,
      argValues: [privateKey, serverKeyData, verifyKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDecryptKeyConstMeta =>
      const TaskConstMeta(
        debugName: "group_decrypt_key",
        argNames: ["privateKey", "serverKeyData", "verifyKey"],
      );

  @override
  Future<String> crateApiGroupGroupDecryptSortableKey(
      {required String groupKey, required String serverKeyData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(groupKey);
        var arg1 = cst_encode_String(serverKeyData);
        return wire.wire__crate__api__group__group_decrypt_sortable_key(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDecryptSortableKeyConstMeta,
      argValues: [groupKey, serverKeyData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDecryptSortableKeyConstMeta =>
      const TaskConstMeta(
        debugName: "group_decrypt_sortable_key",
        argNames: ["groupKey", "serverKeyData"],
      );

  @override
  Future<void> crateApiGroupGroupDeleteGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_delete_group(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDeleteGroupConstMeta,
      argValues: [baseUrl, authToken, jwt, id, adminRank, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDeleteGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_delete_group",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupDeleteSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String joinReqGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(joinReqGroupId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_delete_sent_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDeleteSentJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        joinReqGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDeleteSentJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_delete_sent_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "joinReqGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupDeleteSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String joinReqGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(joinReqGroupId);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_delete_sent_join_req_user(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDeleteSentJoinReqUserConstMeta,
      argValues: [baseUrl, authToken, jwt, joinReqGroupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDeleteSentJoinReqUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_delete_sent_join_req_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "joinReqGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupDoneKeyRotation(
      {required String privateKey,
      required String publicKey,
      required String preGroupKey,
      required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(privateKey);
        var arg1 = cst_encode_String(publicKey);
        var arg2 = cst_encode_String(preGroupKey);
        var arg3 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__group__group_done_key_rotation(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupDoneKeyRotationConstMeta,
      argValues: [privateKey, publicKey, preGroupKey, serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupDoneKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "group_done_key_rotation",
        argNames: ["privateKey", "publicKey", "preGroupKey", "serverOutput"],
      );

  @override
  Future<GroupOutData> crateApiGroupGroupExtractGroupData(
      {required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__group__group_extract_group_data(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_out_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupExtractGroupDataConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupExtractGroupDataConstMeta =>
      const TaskConstMeta(
        debugName: "group_extract_group_data",
        argNames: ["serverOutput"],
      );

  @override
  Future<List<GroupOutDataKeys>> crateApiGroupGroupExtractGroupKeys(
      {required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire.wire__crate__api__group__group_extract_group_keys(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_out_data_keys,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupExtractGroupKeysConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupExtractGroupKeysConstMeta =>
      const TaskConstMeta(
        debugName: "group_extract_group_keys",
        argNames: ["serverOutput"],
      );

  @override
  Future<void> crateApiGroupGroupFinishKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String serverOutput,
      required String preGroupKey,
      required String publicKey,
      required String privateKey,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(serverOutput);
        var arg5 = cst_encode_String(preGroupKey);
        var arg6 = cst_encode_String(publicKey);
        var arg7 = cst_encode_String(privateKey);
        var arg8 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_finish_key_rotation(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupFinishKeyRotationConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        serverOutput,
        preGroupKey,
        publicKey,
        privateKey,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupFinishKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "group_finish_key_rotation",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "serverOutput",
          "preGroupKey",
          "publicKey",
          "privateKey",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupChildrenList>> crateApiGroupGroupGetAllFirstLevelChildren(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(lastFetchedTime);
        var arg5 = cst_encode_String(lastFetchedGroupId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_all_first_level_children(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_children_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetAllFirstLevelChildrenConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        lastFetchedTime,
        lastFetchedGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetAllFirstLevelChildrenConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_all_first_level_children",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupAsMember"
        ],
      );

  @override
  KeyRotationInput crateApiGroupGroupGetDoneKeyRotationServerInput(
      {required String serverOutput}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(serverOutput);
        return wire
            .wire__crate__api__group__group_get_done_key_rotation_server_input(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_key_rotation_input,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetDoneKeyRotationServerInputConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetDoneKeyRotationServerInputConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_done_key_rotation_server_input",
        argNames: ["serverOutput"],
      );

  @override
  Future<GroupOutData> crateApiGroupGroupGetGroupData(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_group_data(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_out_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupDataConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupDataConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_group_data",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<GroupOutDataKeys> crateApiGroupGroupGetGroupKey(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String keyId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(keyId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_group_key(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_out_data_keys,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupKeyConstMeta,
      argValues: [baseUrl, authToken, jwt, id, keyId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupKeyConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_group_key",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "keyId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupOutDataKeys>> crateApiGroupGroupGetGroupKeys(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedKeyId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(lastFetchedTime);
        var arg5 = cst_encode_String(lastFetchedKeyId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_group_keys(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_out_data_keys,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupKeysConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        lastFetchedTime,
        lastFetchedKeyId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupKeysConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_group_keys",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "lastFetchedTime",
          "lastFetchedKeyId",
          "groupAsMember"
        ],
      );

  @override
  Future<GroupDataCheckUpdateServerOutput> crateApiGroupGroupGetGroupUpdates(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_group_updates(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_data_check_update_server_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupUpdatesConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupUpdatesConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_group_updates",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<List<ListGroups>> crateApiGroupGroupGetGroupsForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedGroupId);
        var arg5 = cst_encode_opt_String(groupId);
        return wire.wire__crate__api__group__group_get_groups_for_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_list_groups,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetGroupsForUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        lastFetchedTime,
        lastFetchedGroupId,
        groupId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetGroupsForUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_groups_for_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupId"
        ],
      );

  @override
  Future<List<GroupInviteReqList>> crateApiGroupGroupGetInvitesForUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedGroupId);
        var arg5 = cst_encode_opt_String(groupId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_invites_for_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_invite_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetInvitesForUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        lastFetchedTime,
        lastFetchedGroupId,
        groupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetInvitesForUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_invites_for_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupJoinReqList>> crateApiGroupGroupGetJoinReqs(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(lastFetchedTime);
        var arg6 = cst_encode_String(lastFetchedId);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_join_reqs(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_join_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetJoinReqsConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        lastFetchedTime,
        lastFetchedId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetJoinReqsConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_join_reqs",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "lastFetchedTime",
          "lastFetchedId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupUserListItem>> crateApiGroupGroupGetMember(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String lastFetchedTime,
      required String lastFetchedId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(lastFetchedTime);
        var arg5 = cst_encode_String(lastFetchedId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_member(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_user_list_item,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetMemberConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        lastFetchedTime,
        lastFetchedId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetMemberConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_member",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "lastFetchedTime",
          "lastFetchedId",
          "groupAsMember"
        ],
      );

  @override
  Future<GroupPublicKeyData> crateApiGroupGroupGetPublicKeyData(
      {required String baseUrl,
      required String authToken,
      required String id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(id);
        return wire.wire__crate__api__group__group_get_public_key_data(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_group_public_key_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetPublicKeyDataConstMeta,
      argValues: [baseUrl, authToken, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetPublicKeyDataConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_public_key_data",
        argNames: ["baseUrl", "authToken", "id"],
      );

  @override
  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(lastFetchedTime);
        var arg6 = cst_encode_String(lastFetchedGroupId);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_sent_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_invite_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetSentJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        lastFetchedTime,
        lastFetchedGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetSentJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_sent_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<List<GroupInviteReqList>> crateApiGroupGroupGetSentJoinReqUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String lastFetchedTime,
      required String lastFetchedGroupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(lastFetchedTime);
        var arg4 = cst_encode_String(lastFetchedGroupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_get_sent_join_req_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_group_invite_req_list,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupGetSentJoinReqUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        lastFetchedTime,
        lastFetchedGroupId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupGetSentJoinReqUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_get_sent_join_req_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "lastFetchedTime",
          "lastFetchedGroupId",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupInviteUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int keyCount,
      int? rank,
      required int adminRank,
      required bool autoInvite,
      required bool groupInvite,
      required bool reInvite,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_i_32(keyCount);
        var arg6 = cst_encode_opt_box_autoadd_i_32(rank);
        var arg7 = cst_encode_i_32(adminRank);
        var arg8 = cst_encode_bool(autoInvite);
        var arg9 = cst_encode_bool(groupInvite);
        var arg10 = cst_encode_bool(reInvite);
        var arg11 = cst_encode_String(userPublicKey);
        var arg12 = cst_encode_String(groupKeys);
        var arg13 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_invite_user(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12,
            arg13);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupInviteUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        keyCount,
        rank,
        adminRank,
        autoInvite,
        groupInvite,
        reInvite,
        userPublicKey,
        groupKeys,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupInviteUserConstMeta =>
      const TaskConstMeta(
        debugName: "group_invite_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "keyCount",
          "rank",
          "adminRank",
          "autoInvite",
          "groupInvite",
          "reInvite",
          "userPublicKey",
          "groupKeys",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupInviteUserSession(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required bool autoInvite,
      required String sessionId,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_bool(autoInvite);
        var arg5 = cst_encode_String(sessionId);
        var arg6 = cst_encode_String(userPublicKey);
        var arg7 = cst_encode_String(groupKeys);
        var arg8 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_invite_user_session(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupInviteUserSessionConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        autoInvite,
        sessionId,
        userPublicKey,
        groupKeys,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupInviteUserSessionConstMeta =>
      const TaskConstMeta(
        debugName: "group_invite_user_session",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "autoInvite",
          "sessionId",
          "userPublicKey",
          "groupKeys",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupJoinReqConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupJoinReqConstMeta => const TaskConstMeta(
        debugName: "group_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupJoinUserSession(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String sessionId,
      required String userPublicKey,
      required String groupKeys,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(sessionId);
        var arg5 = cst_encode_String(userPublicKey);
        var arg6 = cst_encode_String(groupKeys);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_join_user_session(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupJoinUserSessionConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        sessionId,
        userPublicKey,
        groupKeys,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupJoinUserSessionConstMeta =>
      const TaskConstMeta(
        debugName: "group_join_user_session",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "sessionId",
          "userPublicKey",
          "groupKeys",
          "groupAsMember"
        ],
      );

  @override
  Future<String> crateApiGroupGroupKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String publicKey,
      required String preGroupKey,
      String? signKey,
      required String starter,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(publicKey);
        var arg5 = cst_encode_String(preGroupKey);
        var arg6 = cst_encode_opt_String(signKey);
        var arg7 = cst_encode_String(starter);
        var arg8 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_key_rotation(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupKeyRotationConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        publicKey,
        preGroupKey,
        signKey,
        starter,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "group_key_rotation",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "publicKey",
          "preGroupKey",
          "signKey",
          "starter",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupKickUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_i_32(adminRank);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_kick_user(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupKickUserConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        adminRank,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupKickUserConstMeta => const TaskConstMeta(
        debugName: "group_kick_user",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<List<KeyRotationGetOut>> crateApiGroupGroupPreDoneKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_pre_done_key_rotation(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_key_rotation_get_out,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupPreDoneKeyRotationConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupPreDoneKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "group_pre_done_key_rotation",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<String> crateApiGroupGroupPrepareCreateGroup(
      {required String creatorsPublicKey,
      String? signKey,
      required String starter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(creatorsPublicKey);
        var arg1 = cst_encode_opt_String(signKey);
        var arg2 = cst_encode_String(starter);
        return wire.wire__crate__api__group__group_prepare_create_group(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupPrepareCreateGroupConstMeta,
      argValues: [creatorsPublicKey, signKey, starter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupPrepareCreateGroupConstMeta =>
      const TaskConstMeta(
        debugName: "group_prepare_create_group",
        argNames: ["creatorsPublicKey", "signKey", "starter"],
      );

  @override
  Future<String> crateApiGroupGroupPrepareKeyRotation(
      {required String preGroupKey,
      required String publicKey,
      String? signKey,
      required String starter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(preGroupKey);
        var arg1 = cst_encode_String(publicKey);
        var arg2 = cst_encode_opt_String(signKey);
        var arg3 = cst_encode_String(starter);
        return wire.wire__crate__api__group__group_prepare_key_rotation(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupPrepareKeyRotationConstMeta,
      argValues: [preGroupKey, publicKey, signKey, starter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupPrepareKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "group_prepare_key_rotation",
        argNames: ["preGroupKey", "publicKey", "signKey", "starter"],
      );

  @override
  Future<String> crateApiGroupGroupPrepareKeysForNewMember(
      {required String userPublicKey,
      required String groupKeys,
      required int keyCount,
      int? rank,
      required int adminRank}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(userPublicKey);
        var arg1 = cst_encode_String(groupKeys);
        var arg2 = cst_encode_i_32(keyCount);
        var arg3 = cst_encode_opt_box_autoadd_i_32(rank);
        var arg4 = cst_encode_i_32(adminRank);
        return wire.wire__crate__api__group__group_prepare_keys_for_new_member(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupPrepareKeysForNewMemberConstMeta,
      argValues: [userPublicKey, groupKeys, keyCount, rank, adminRank],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupPrepareKeysForNewMemberConstMeta =>
      const TaskConstMeta(
        debugName: "group_prepare_keys_for_new_member",
        argNames: [
          "userPublicKey",
          "groupKeys",
          "keyCount",
          "rank",
          "adminRank"
        ],
      );

  @override
  String crateApiGroupGroupPrepareUpdateRank(
      {required String userId, required int rank, required int adminRank}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(userId);
        var arg1 = cst_encode_i_32(rank);
        var arg2 = cst_encode_i_32(adminRank);
        return wire.wire__crate__api__group__group_prepare_update_rank(
            arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupPrepareUpdateRankConstMeta,
      argValues: [userId, rank, adminRank],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupPrepareUpdateRankConstMeta =>
      const TaskConstMeta(
        debugName: "group_prepare_update_rank",
        argNames: ["userId", "rank", "adminRank"],
      );

  @override
  Future<void> crateApiGroupGroupRejectInvite(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupId);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_reject_invite(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupRejectInviteConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupId, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupRejectInviteConstMeta =>
      const TaskConstMeta(
        debugName: "group_reject_invite",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "groupId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupRejectJoinReq(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      required String rejectedUserId,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_String(rejectedUserId);
        var arg6 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_reject_join_req(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupRejectJoinReqConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        adminRank,
        rejectedUserId,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupRejectJoinReqConstMeta =>
      const TaskConstMeta(
        debugName: "group_reject_join_req",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "rejectedUserId",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupStopGroupInvites(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_i_32(adminRank);
        var arg5 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_stop_group_invites(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupStopGroupInvitesConstMeta,
      argValues: [baseUrl, authToken, jwt, id, adminRank, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupStopGroupInvitesConstMeta =>
      const TaskConstMeta(
        debugName: "group_stop_group_invites",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<void> crateApiGroupGroupUpdateRank(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      required String userId,
      required int rank,
      required int adminRank,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_String(userId);
        var arg5 = cst_encode_i_32(rank);
        var arg6 = cst_encode_i_32(adminRank);
        var arg7 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__group_update_rank(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupGroupUpdateRankConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        id,
        userId,
        rank,
        adminRank,
        groupAsMember
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupGroupUpdateRankConstMeta =>
      const TaskConstMeta(
        debugName: "group_update_rank",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "id",
          "userId",
          "rank",
          "adminRank",
          "groupAsMember"
        ],
      );

  @override
  Future<UserInitServerOutput> crateApiUserInitUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(refreshToken);
        return wire.wire__crate__api__user__init_user(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_init_server_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserInitUserConstMeta,
      argValues: [baseUrl, authToken, jwt, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserInitUserConstMeta => const TaskConstMeta(
        debugName: "init_user",
        argNames: ["baseUrl", "authToken", "jwt", "refreshToken"],
      );

  @override
  Future<void> crateApiGroupLeaveGroup(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String id,
      String? groupAsMember}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(id);
        var arg4 = cst_encode_opt_String(groupAsMember);
        return wire.wire__crate__api__group__leave_group(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiGroupLeaveGroupConstMeta,
      argValues: [baseUrl, authToken, jwt, id, groupAsMember],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGroupLeaveGroupConstMeta => const TaskConstMeta(
        debugName: "leave_group",
        argNames: ["baseUrl", "authToken", "jwt", "id", "groupAsMember"],
      );

  @override
  Future<UserLoginOut> crateApiUserLogin(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(password);
        return wire.wire__crate__api__user__login(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_login_out,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserLoginConstMeta,
      argValues: [baseUrl, authToken, userIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserLoginConstMeta => const TaskConstMeta(
        debugName: "login",
        argNames: ["baseUrl", "authToken", "userIdentifier", "password"],
      );

  @override
  Future<UserData> crateApiUserMfaLogin(
      {required String baseUrl,
      required String authToken,
      required String masterKeyEncryption,
      required String authKey,
      required String userIdentifier,
      required String token,
      required bool recovery}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(masterKeyEncryption);
        var arg3 = cst_encode_String(authKey);
        var arg4 = cst_encode_String(userIdentifier);
        var arg5 = cst_encode_String(token);
        var arg6 = cst_encode_bool(recovery);
        return wire.wire__crate__api__user__mfa_login(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserMfaLoginConstMeta,
      argValues: [
        baseUrl,
        authToken,
        masterKeyEncryption,
        authKey,
        userIdentifier,
        token,
        recovery
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserMfaLoginConstMeta => const TaskConstMeta(
        debugName: "mfa_login",
        argNames: [
          "baseUrl",
          "authToken",
          "masterKeyEncryption",
          "authKey",
          "userIdentifier",
          "token",
          "recovery"
        ],
      );

  @override
  String crateApiUserPrepareCheckUserIdentifierAvailable(
      {required String userIdentifier}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(userIdentifier);
        return wire
            .wire__crate__api__user__prepare_check_user_identifier_available(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserPrepareCheckUserIdentifierAvailableConstMeta,
      argValues: [userIdentifier],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserPrepareCheckUserIdentifierAvailableConstMeta =>
      const TaskConstMeta(
        debugName: "prepare_check_user_identifier_available",
        argNames: ["userIdentifier"],
      );

  @override
  Future<String> crateApiUserPrepareRegister(
      {required String userIdentifier, required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(userIdentifier);
        var arg1 = cst_encode_String(password);
        return wire.wire__crate__api__user__prepare_register(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserPrepareRegisterConstMeta,
      argValues: [userIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserPrepareRegisterConstMeta =>
      const TaskConstMeta(
        debugName: "prepare_register",
        argNames: ["userIdentifier", "password"],
      );

  @override
  Future<PreRegisterDeviceData> crateApiUserPrepareRegisterDevice(
      {required String serverOutput,
      required String userKeys,
      required int keyCount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        var arg1 = cst_encode_String(userKeys);
        var arg2 = cst_encode_i_32(keyCount);
        return wire.wire__crate__api__user__prepare_register_device(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pre_register_device_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserPrepareRegisterDeviceConstMeta,
      argValues: [serverOutput, userKeys, keyCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserPrepareRegisterDeviceConstMeta =>
      const TaskConstMeta(
        debugName: "prepare_register_device",
        argNames: ["serverOutput", "userKeys", "keyCount"],
      );

  @override
  Future<String> crateApiUserPrepareRegisterDeviceStart(
      {required String deviceIdentifier, required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(deviceIdentifier);
        var arg1 = cst_encode_String(password);
        return wire.wire__crate__api__user__prepare_register_device_start(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserPrepareRegisterDeviceStartConstMeta,
      argValues: [deviceIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserPrepareRegisterDeviceStartConstMeta =>
      const TaskConstMeta(
        debugName: "prepare_register_device_start",
        argNames: ["deviceIdentifier", "password"],
      );

  @override
  Future<String> crateApiUserRefreshJwt(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(refreshToken);
        return wire.wire__crate__api__user__refresh_jwt(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRefreshJwtConstMeta,
      argValues: [baseUrl, authToken, jwt, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRefreshJwtConstMeta => const TaskConstMeta(
        debugName: "refresh_jwt",
        argNames: ["baseUrl", "authToken", "jwt", "refreshToken"],
      );

  @override
  Future<String> crateApiUserRegister(
      {required String baseUrl,
      required String authToken,
      required String userIdentifier,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userIdentifier);
        var arg3 = cst_encode_String(password);
        return wire.wire__crate__api__user__register(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterConstMeta,
      argValues: [baseUrl, authToken, userIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterConstMeta => const TaskConstMeta(
        debugName: "register",
        argNames: ["baseUrl", "authToken", "userIdentifier", "password"],
      );

  @override
  Future<RegisterDeviceData> crateApiUserRegisterDevice(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String serverOutput,
      required int keyCount,
      required String userKeys}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(serverOutput);
        var arg4 = cst_encode_i_32(keyCount);
        var arg5 = cst_encode_String(userKeys);
        return wire.wire__crate__api__user__register_device(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_register_device_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterDeviceConstMeta,
      argValues: [baseUrl, authToken, jwt, serverOutput, keyCount, userKeys],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterDeviceConstMeta => const TaskConstMeta(
        debugName: "register_device",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "serverOutput",
          "keyCount",
          "userKeys"
        ],
      );

  @override
  Future<String> crateApiUserRegisterDeviceStart(
      {required String baseUrl,
      required String authToken,
      required String deviceIdentifier,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(deviceIdentifier);
        var arg3 = cst_encode_String(password);
        return wire.wire__crate__api__user__register_device_start(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterDeviceStartConstMeta,
      argValues: [baseUrl, authToken, deviceIdentifier, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterDeviceStartConstMeta =>
      const TaskConstMeta(
        debugName: "register_device_start",
        argNames: ["baseUrl", "authToken", "deviceIdentifier", "password"],
      );

  @override
  Future<OtpRegisterUrl> crateApiUserRegisterOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(issuer);
        var arg4 = cst_encode_String(audience);
        return wire.wire__crate__api__user__register_otp(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register_url,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterOtpConstMeta,
      argValues: [baseUrl, authToken, jwt, issuer, audience],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterOtpConstMeta => const TaskConstMeta(
        debugName: "register_otp",
        argNames: ["baseUrl", "authToken", "jwt", "issuer", "audience"],
      );

  @override
  Future<OtpRegister> crateApiUserRegisterRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__register_raw_otp(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserRegisterRawOtpConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserRegisterRawOtpConstMeta => const TaskConstMeta(
        debugName: "register_raw_otp",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<OtpRegisterUrl> crateApiUserResetOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String issuer,
      required String audience}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(issuer);
        var arg4 = cst_encode_String(audience);
        return wire.wire__crate__api__user__reset_otp(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register_url,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserResetOtpConstMeta,
      argValues: [baseUrl, authToken, jwt, issuer, audience],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserResetOtpConstMeta => const TaskConstMeta(
        debugName: "reset_otp",
        argNames: ["baseUrl", "authToken", "jwt", "issuer", "audience"],
      );

  @override
  Future<void> crateApiUserResetPassword(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String newPassword,
      required String decryptedPrivateKey,
      required String decryptedSignKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(newPassword);
        var arg4 = cst_encode_String(decryptedPrivateKey);
        var arg5 = cst_encode_String(decryptedSignKey);
        return wire.wire__crate__api__user__reset_password(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserResetPasswordConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        newPassword,
        decryptedPrivateKey,
        decryptedSignKey
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserResetPasswordConstMeta => const TaskConstMeta(
        debugName: "reset_password",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "newPassword",
          "decryptedPrivateKey",
          "decryptedSignKey"
        ],
      );

  @override
  Future<OtpRegister> crateApiUserResetRawOtp(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__reset_raw_otp(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_otp_register,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserResetRawOtpConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserResetRawOtpConstMeta => const TaskConstMeta(
        debugName: "reset_raw_otp",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<String> crateApiCryptoSearch(
      {required String key, required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(data);
        return wire.wire__crate__api__crypto__search(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSearchConstMeta,
      argValues: [key, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSearchConstMeta => const TaskConstMeta(
        debugName: "search",
        argNames: ["key", "data"],
      );

  @override
  Future<SortableEncryptOutput> crateApiCryptoSortableEncryptNumber(
      {required String key, required BigInt data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_u_64(data);
        return wire.wire__crate__api__crypto__sortable_encrypt_number(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_sortable_encrypt_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSortableEncryptNumberConstMeta,
      argValues: [key, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSortableEncryptNumberConstMeta =>
      const TaskConstMeta(
        debugName: "sortable_encrypt_number",
        argNames: ["key", "data"],
      );

  @override
  Future<BigInt> crateApiCryptoSortableEncryptRawNumber(
      {required String key, required BigInt data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_u_64(data);
        return wire.wire__crate__api__crypto__sortable_encrypt_raw_number(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSortableEncryptRawNumberConstMeta,
      argValues: [key, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSortableEncryptRawNumberConstMeta =>
      const TaskConstMeta(
        debugName: "sortable_encrypt_raw_number",
        argNames: ["key", "data"],
      );

  @override
  Future<BigInt> crateApiCryptoSortableEncryptRawString(
      {required String key, required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(data);
        return wire.wire__crate__api__crypto__sortable_encrypt_raw_string(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSortableEncryptRawStringConstMeta,
      argValues: [key, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSortableEncryptRawStringConstMeta =>
      const TaskConstMeta(
        debugName: "sortable_encrypt_raw_string",
        argNames: ["key", "data"],
      );

  @override
  Future<SortableEncryptOutput> crateApiCryptoSortableEncryptString(
      {required String key, required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(key);
        var arg1 = cst_encode_String(data);
        return wire.wire__crate__api__crypto__sortable_encrypt_string(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_sortable_encrypt_output,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSortableEncryptStringConstMeta,
      argValues: [key, data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSortableEncryptStringConstMeta =>
      const TaskConstMeta(
        debugName: "sortable_encrypt_string",
        argNames: ["key", "data"],
      );

  @override
  Future<EncryptedHead> crateApiCryptoSplitHeadAndEncryptedData(
      {required List<int> data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_list_prim_u_8_loose(data);
        return wire.wire__crate__api__crypto__split_head_and_encrypted_data(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_encrypted_head,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSplitHeadAndEncryptedDataConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSplitHeadAndEncryptedDataConstMeta =>
      const TaskConstMeta(
        debugName: "split_head_and_encrypted_data",
        argNames: ["data"],
      );

  @override
  Future<EncryptedHead> crateApiCryptoSplitHeadAndEncryptedString(
      {required String data}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(data);
        return wire.wire__crate__api__crypto__split_head_and_encrypted_string(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_encrypted_head,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiCryptoSplitHeadAndEncryptedStringConstMeta,
      argValues: [data],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCryptoSplitHeadAndEncryptedStringConstMeta =>
      const TaskConstMeta(
        debugName: "split_head_and_encrypted_string",
        argNames: ["data"],
      );

  @override
  Future<void> crateApiUserUpdateUser(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String userIdentifier}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(userIdentifier);
        return wire.wire__crate__api__user__update_user(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUpdateUserConstMeta,
      argValues: [baseUrl, authToken, jwt, userIdentifier],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUpdateUserConstMeta => const TaskConstMeta(
        debugName: "update_user",
        argNames: ["baseUrl", "authToken", "jwt", "userIdentifier"],
      );

  @override
  Future<String> crateApiUserUserCreateSafetyNumber(
      {required String verifyKey1,
      required String userId1,
      String? verifyKey2,
      String? userId2}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(verifyKey1);
        var arg1 = cst_encode_String(userId1);
        var arg2 = cst_encode_opt_String(verifyKey2);
        var arg3 = cst_encode_opt_String(userId2);
        return wire.wire__crate__api__user__user_create_safety_number(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserCreateSafetyNumberConstMeta,
      argValues: [verifyKey1, userId1, verifyKey2, userId2],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserCreateSafetyNumberConstMeta =>
      const TaskConstMeta(
        debugName: "user_create_safety_number",
        argNames: ["verifyKey1", "userId1", "verifyKey2", "userId2"],
      );

  @override
  Future<void> crateApiUserUserDeviceKeySessionUpload(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String sessionId,
      required String userPublicKey,
      required String groupKeys}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(sessionId);
        var arg4 = cst_encode_String(userPublicKey);
        var arg5 = cst_encode_String(groupKeys);
        return wire.wire__crate__api__user__user_device_key_session_upload(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserDeviceKeySessionUploadConstMeta,
      argValues: [baseUrl, authToken, jwt, sessionId, userPublicKey, groupKeys],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserDeviceKeySessionUploadConstMeta =>
      const TaskConstMeta(
        debugName: "user_device_key_session_upload",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "sessionId",
          "userPublicKey",
          "groupKeys"
        ],
      );

  @override
  Future<UserPublicKeyData> crateApiUserUserFetchPublicKey(
      {required String baseUrl,
      required String authToken,
      required String userId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userId);
        return wire.wire__crate__api__user__user_fetch_public_key(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_public_key_data,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserFetchPublicKeyConstMeta,
      argValues: [baseUrl, authToken, userId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserFetchPublicKeyConstMeta =>
      const TaskConstMeta(
        debugName: "user_fetch_public_key",
        argNames: ["baseUrl", "authToken", "userId"],
      );

  @override
  Future<String> crateApiUserUserFetchVerifyKey(
      {required String baseUrl,
      required String authToken,
      required String userId,
      required String verifyKeyId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(userId);
        var arg3 = cst_encode_String(verifyKeyId);
        return wire.wire__crate__api__user__user_fetch_verify_key(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserFetchVerifyKeyConstMeta,
      argValues: [baseUrl, authToken, userId, verifyKeyId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserFetchVerifyKeyConstMeta =>
      const TaskConstMeta(
        debugName: "user_fetch_verify_key",
        argNames: ["baseUrl", "authToken", "userId", "verifyKeyId"],
      );

  @override
  Future<void> crateApiUserUserFinishKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String serverOutput,
      required String preGroupKey,
      required String publicKey,
      required String privateKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(serverOutput);
        var arg4 = cst_encode_String(preGroupKey);
        var arg5 = cst_encode_String(publicKey);
        var arg6 = cst_encode_String(privateKey);
        return wire.wire__crate__api__user__user_finish_key_rotation(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserFinishKeyRotationConstMeta,
      argValues: [
        baseUrl,
        authToken,
        jwt,
        serverOutput,
        preGroupKey,
        publicKey,
        privateKey
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserFinishKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "user_finish_key_rotation",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "serverOutput",
          "preGroupKey",
          "publicKey",
          "privateKey"
        ],
      );

  @override
  Future<KeyRotationInput> crateApiUserUserGetDoneKeyRotationServerInput(
      {required String serverOutput}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(serverOutput);
        return wire
            .wire__crate__api__user__user_get_done_key_rotation_server_input(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_key_rotation_input,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserGetDoneKeyRotationServerInputConstMeta,
      argValues: [serverOutput],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserGetDoneKeyRotationServerInputConstMeta =>
      const TaskConstMeta(
        debugName: "user_get_done_key_rotation_server_input",
        argNames: ["serverOutput"],
      );

  @override
  Future<String> crateApiUserUserKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt,
      required String publicDeviceKey,
      required String preUserKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        var arg3 = cst_encode_String(publicDeviceKey);
        var arg4 = cst_encode_String(preUserKey);
        return wire.wire__crate__api__user__user_key_rotation(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserKeyRotationConstMeta,
      argValues: [baseUrl, authToken, jwt, publicDeviceKey, preUserKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "user_key_rotation",
        argNames: [
          "baseUrl",
          "authToken",
          "jwt",
          "publicDeviceKey",
          "preUserKey"
        ],
      );

  @override
  Future<List<KeyRotationGetOut>> crateApiUserUserPreDoneKeyRotation(
      {required String baseUrl,
      required String authToken,
      required String jwt}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(baseUrl);
        var arg1 = cst_encode_String(authToken);
        var arg2 = cst_encode_String(jwt);
        return wire.wire__crate__api__user__user_pre_done_key_rotation(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_key_rotation_get_out,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserPreDoneKeyRotationConstMeta,
      argValues: [baseUrl, authToken, jwt],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserPreDoneKeyRotationConstMeta =>
      const TaskConstMeta(
        debugName: "user_pre_done_key_rotation",
        argNames: ["baseUrl", "authToken", "jwt"],
      );

  @override
  Future<bool> crateApiUserUserVerifyUserPublicKey(
      {required String verifyKey, required String publicKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(verifyKey);
        var arg1 = cst_encode_String(publicKey);
        return wire.wire__crate__api__user__user_verify_user_public_key(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_String,
      ),
      constMeta: kCrateApiUserUserVerifyUserPublicKeyConstMeta,
      argValues: [verifyKey, publicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUserUserVerifyUserPublicKeyConstMeta =>
      const TaskConstMeta(
        debugName: "user_verify_user_public_key",
        argNames: ["verifyKey", "publicKey"],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  BelongsToType dco_decode_belongs_to_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BelongsToType.values[raw as int];
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Claims dco_decode_claims(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Claims(
      aud: dco_decode_String(arr[0]),
      sub: dco_decode_String(arr[1]),
      exp: dco_decode_usize(arr[2]),
      iat: dco_decode_usize(arr[3]),
      fresh: dco_decode_bool(arr[4]),
    );
  }

  @protected
  CryptoRawOutput dco_decode_crypto_raw_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return CryptoRawOutput(
      head: dco_decode_String(arr[0]),
      data: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  DeviceKeyData dco_decode_device_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return DeviceKeyData(
      privateKey: dco_decode_String(arr[0]),
      publicKey: dco_decode_String(arr[1]),
      signKey: dco_decode_String(arr[2]),
      verifyKey: dco_decode_String(arr[3]),
      exportedPublicKey: dco_decode_String(arr[4]),
      exportedVerifyKey: dco_decode_String(arr[5]),
    );
  }

  @protected
  EncryptedHead dco_decode_encrypted_head(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EncryptedHead(
      id: dco_decode_String(arr[0]),
      signId: dco_decode_opt_String(arr[1]),
      signAlg: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  FileData dco_decode_file_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return FileData(
      fileId: dco_decode_String(arr[0]),
      masterKeyId: dco_decode_String(arr[1]),
      owner: dco_decode_String(arr[2]),
      belongsTo: dco_decode_opt_String(arr[3]),
      belongsToType: dco_decode_belongs_to_type(arr[4]),
      encryptedKey: dco_decode_String(arr[5]),
      encryptedKeyAlg: dco_decode_String(arr[6]),
      encryptedFileName: dco_decode_opt_String(arr[7]),
      partList: dco_decode_list_file_part_list_item(arr[8]),
    );
  }

  @protected
  FileDoneRegister dco_decode_file_done_register(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FileDoneRegister(
      fileId: dco_decode_String(arr[0]),
      sessionId: dco_decode_String(arr[1]),
    );
  }

  @protected
  FileDownloadResult dco_decode_file_download_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FileDownloadResult(
      nextFileKey: dco_decode_String(arr[0]),
      file: dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  FilePartListItem dco_decode_file_part_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FilePartListItem(
      partId: dco_decode_String(arr[0]),
      sequence: dco_decode_i_32(arr[1]),
      externStorage: dco_decode_bool(arr[2]),
    );
  }

  @protected
  FilePrepareRegister dco_decode_file_prepare_register(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return FilePrepareRegister(
      encryptedFileName: dco_decode_opt_String(arr[0]),
      serverInput: dco_decode_String(arr[1]),
    );
  }

  @protected
  FileRegisterOutput dco_decode_file_register_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return FileRegisterOutput(
      fileId: dco_decode_String(arr[0]),
      sessionId: dco_decode_String(arr[1]),
      encryptedFileName: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  GeneratedRegisterData dco_decode_generated_register_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GeneratedRegisterData(
      identifier: dco_decode_String(arr[0]),
      password: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupChildrenList dco_decode_group_children_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return GroupChildrenList(
      groupId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      parent: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  GroupDataCheckUpdateServerOutput
      dco_decode_group_data_check_update_server_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GroupDataCheckUpdateServerOutput(
      keyUpdate: dco_decode_bool(arr[0]),
      rank: dco_decode_i_32(arr[1]),
    );
  }

  @protected
  GroupInviteReqList dco_decode_group_invite_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GroupInviteReqList(
      groupId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupJoinReqList dco_decode_group_join_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return GroupJoinReqList(
      userId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      userType: dco_decode_i_32(arr[2]),
    );
  }

  @protected
  GroupKeyData dco_decode_group_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return GroupKeyData(
      privateGroupKey: dco_decode_String(arr[0]),
      publicGroupKey: dco_decode_String(arr[1]),
      exportedPublicKey: dco_decode_String(arr[2]),
      groupKey: dco_decode_String(arr[3]),
      time: dco_decode_String(arr[4]),
      groupKeyId: dco_decode_String(arr[5]),
    );
  }

  @protected
  GroupOutData dco_decode_group_out_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return GroupOutData(
      groupId: dco_decode_String(arr[0]),
      parentGroupId: dco_decode_opt_String(arr[1]),
      rank: dco_decode_i_32(arr[2]),
      keyUpdate: dco_decode_bool(arr[3]),
      createdTime: dco_decode_String(arr[4]),
      joinedTime: dco_decode_String(arr[5]),
      keys: dco_decode_list_group_out_data_keys(arr[6]),
      hmacKeys: dco_decode_list_group_out_data_hmac_keys(arr[7]),
      sortableKeys: dco_decode_list_group_out_data_sortable_keys(arr[8]),
      accessByGroupAsMember: dco_decode_opt_String(arr[9]),
      accessByParentGroup: dco_decode_opt_String(arr[10]),
      isConnectedGroup: dco_decode_bool(arr[11]),
    );
  }

  @protected
  GroupOutDataHmacKeys dco_decode_group_out_data_hmac_keys(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GroupOutDataHmacKeys(
      groupKeyId: dco_decode_String(arr[0]),
      keyData: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupOutDataKeys dco_decode_group_out_data_keys(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GroupOutDataKeys(
      privateKeyId: dco_decode_String(arr[0]),
      keyData: dco_decode_String(arr[1]),
      signedByUserId: dco_decode_opt_String(arr[2]),
      signedByUserSignKeyId: dco_decode_opt_String(arr[3]),
    );
  }

  @protected
  GroupOutDataSortableKeys dco_decode_group_out_data_sortable_keys(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GroupOutDataSortableKeys(
      groupKeyId: dco_decode_String(arr[0]),
      keyData: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupPublicKeyData dco_decode_group_public_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return GroupPublicKeyData(
      publicKey: dco_decode_String(arr[0]),
      publicKeyId: dco_decode_String(arr[1]),
    );
  }

  @protected
  GroupUserListItem dco_decode_group_user_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GroupUserListItem(
      userId: dco_decode_String(arr[0]),
      rank: dco_decode_i_32(arr[1]),
      joinedTime: dco_decode_String(arr[2]),
      userType: dco_decode_i_32(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  KeyRotationGetOut dco_decode_key_rotation_get_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return KeyRotationGetOut(
      preGroupKeyId: dco_decode_String(arr[0]),
      newGroupKeyId: dco_decode_String(arr[1]),
      encryptedEphKeyKeyId: dco_decode_String(arr[2]),
      serverOutput: dco_decode_String(arr[3]),
    );
  }

  @protected
  KeyRotationInput dco_decode_key_rotation_input(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return KeyRotationInput(
      error: dco_decode_opt_String(arr[0]),
      encryptedEphemeralKeyByGroupKeyAndPublicKey: dco_decode_String(arr[1]),
      encryptedGroupKeyByEphemeral: dco_decode_String(arr[2]),
      ephemeralAlg: dco_decode_String(arr[3]),
      encryptedEphKeyKeyId: dco_decode_String(arr[4]),
      previousGroupKeyId: dco_decode_String(arr[5]),
      time: dco_decode_String(arr[6]),
      newGroupKeyId: dco_decode_String(arr[7]),
    );
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<FilePartListItem> dco_decode_list_file_part_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_file_part_list_item).toList();
  }

  @protected
  List<GroupChildrenList> dco_decode_list_group_children_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_children_list).toList();
  }

  @protected
  List<GroupInviteReqList> dco_decode_list_group_invite_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_group_invite_req_list)
        .toList();
  }

  @protected
  List<GroupJoinReqList> dco_decode_list_group_join_req_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_join_req_list).toList();
  }

  @protected
  List<GroupOutDataHmacKeys> dco_decode_list_group_out_data_hmac_keys(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_group_out_data_hmac_keys)
        .toList();
  }

  @protected
  List<GroupOutDataKeys> dco_decode_list_group_out_data_keys(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_out_data_keys).toList();
  }

  @protected
  List<GroupOutDataSortableKeys> dco_decode_list_group_out_data_sortable_keys(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_group_out_data_sortable_keys)
        .toList();
  }

  @protected
  List<GroupUserListItem> dco_decode_list_group_user_list_item(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_group_user_list_item).toList();
  }

  @protected
  ListGroups dco_decode_list_groups(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ListGroups(
      groupId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      joinedTime: dco_decode_String(arr[2]),
      rank: dco_decode_i_32(arr[3]),
      parent: dco_decode_opt_String(arr[4]),
    );
  }

  @protected
  List<KeyRotationGetOut> dco_decode_list_key_rotation_get_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_key_rotation_get_out).toList();
  }

  @protected
  List<ListGroups> dco_decode_list_list_groups(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_list_groups).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<UserDeviceList> dco_decode_list_user_device_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_user_device_list).toList();
  }

  @protected
  List<UserKeyData> dco_decode_list_user_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_user_key_data).toList();
  }

  @protected
  NonRegisteredKeyOutput dco_decode_non_registered_key_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return NonRegisteredKeyOutput(
      key: dco_decode_String(arr[0]),
      encryptedKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  OtpRecoveryKeysOutput dco_decode_otp_recovery_keys_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OtpRecoveryKeysOutput(
      keys: dco_decode_list_String(arr[0]),
    );
  }

  @protected
  OtpRegister dco_decode_otp_register(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return OtpRegister(
      secret: dco_decode_String(arr[0]),
      alg: dco_decode_String(arr[1]),
      recover: dco_decode_list_String(arr[2]),
    );
  }

  @protected
  OtpRegisterUrl dco_decode_otp_register_url(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OtpRegisterUrl(
      url: dco_decode_String(arr[0]),
      recover: dco_decode_list_String(arr[1]),
    );
  }

  @protected
  PreRegisterDeviceData dco_decode_pre_register_device_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PreRegisterDeviceData(
      input: dco_decode_String(arr[0]),
      exportedPublicKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  RegisterDeviceData dco_decode_register_device_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RegisterDeviceData(
      sessionId: dco_decode_String(arr[0]),
      exportedPublicKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  SearchableCreateOutput dco_decode_searchable_create_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SearchableCreateOutput(
      hashes: dco_decode_list_String(arr[0]),
      alg: dco_decode_String(arr[1]),
      keyId: dco_decode_String(arr[2]),
    );
  }

  @protected
  SortableEncryptOutput dco_decode_sortable_encrypt_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SortableEncryptOutput(
      number: dco_decode_u_64(arr[0]),
      alg: dco_decode_String(arr[1]),
      keyId: dco_decode_String(arr[2]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserData dco_decode_user_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return UserData(
      jwt: dco_decode_String(arr[0]),
      userId: dco_decode_String(arr[1]),
      deviceId: dco_decode_String(arr[2]),
      refreshToken: dco_decode_String(arr[3]),
      keys: dco_decode_device_key_data(arr[4]),
      userKeys: dco_decode_list_user_key_data(arr[5]),
      hmacKeys: dco_decode_list_group_out_data_hmac_keys(arr[6]),
    );
  }

  @protected
  UserDeviceList dco_decode_user_device_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UserDeviceList(
      deviceId: dco_decode_String(arr[0]),
      time: dco_decode_String(arr[1]),
      deviceIdentifier: dco_decode_String(arr[2]),
    );
  }

  @protected
  UserInitServerOutput dco_decode_user_init_server_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return UserInitServerOutput(
      jwt: dco_decode_String(arr[0]),
      invites: dco_decode_list_group_invite_req_list(arr[1]),
    );
  }

  @protected
  UserKeyData dco_decode_user_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return UserKeyData(
      privateKey: dco_decode_String(arr[0]),
      publicKey: dco_decode_String(arr[1]),
      groupKey: dco_decode_String(arr[2]),
      time: dco_decode_String(arr[3]),
      groupKeyId: dco_decode_String(arr[4]),
      signKey: dco_decode_String(arr[5]),
      verifyKey: dco_decode_String(arr[6]),
      exportedPublicKey: dco_decode_String(arr[7]),
      exportedPublicKeySigKeyId: dco_decode_opt_String(arr[8]),
      exportedVerifyKey: dco_decode_String(arr[9]),
    );
  }

  @protected
  UserLoginOut dco_decode_user_login_out(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UserLoginOut(
      direct: dco_decode_opt_String(arr[0]),
      masterKey: dco_decode_opt_String(arr[1]),
      authKey: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  UserPublicKeyData dco_decode_user_public_key_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return UserPublicKeyData(
      publicKey: dco_decode_String(arr[0]),
      publicKeyId: dco_decode_String(arr[1]),
      publicKeySigKeyId: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  BelongsToType sse_decode_belongs_to_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BelongsToType.values[inner];
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  Claims sse_decode_claims(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_aud = sse_decode_String(deserializer);
    var var_sub = sse_decode_String(deserializer);
    var var_exp = sse_decode_usize(deserializer);
    var var_iat = sse_decode_usize(deserializer);
    var var_fresh = sse_decode_bool(deserializer);
    return Claims(
        aud: var_aud,
        sub: var_sub,
        exp: var_exp,
        iat: var_iat,
        fresh: var_fresh);
  }

  @protected
  CryptoRawOutput sse_decode_crypto_raw_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_head = sse_decode_String(deserializer);
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return CryptoRawOutput(head: var_head, data: var_data);
  }

  @protected
  DeviceKeyData sse_decode_device_key_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKey = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    var var_signKey = sse_decode_String(deserializer);
    var var_verifyKey = sse_decode_String(deserializer);
    var var_exportedPublicKey = sse_decode_String(deserializer);
    var var_exportedVerifyKey = sse_decode_String(deserializer);
    return DeviceKeyData(
        privateKey: var_privateKey,
        publicKey: var_publicKey,
        signKey: var_signKey,
        verifyKey: var_verifyKey,
        exportedPublicKey: var_exportedPublicKey,
        exportedVerifyKey: var_exportedVerifyKey);
  }

  @protected
  EncryptedHead sse_decode_encrypted_head(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_signId = sse_decode_opt_String(deserializer);
    var var_signAlg = sse_decode_opt_String(deserializer);
    return EncryptedHead(id: var_id, signId: var_signId, signAlg: var_signAlg);
  }

  @protected
  FileData sse_decode_file_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fileId = sse_decode_String(deserializer);
    var var_masterKeyId = sse_decode_String(deserializer);
    var var_owner = sse_decode_String(deserializer);
    var var_belongsTo = sse_decode_opt_String(deserializer);
    var var_belongsToType = sse_decode_belongs_to_type(deserializer);
    var var_encryptedKey = sse_decode_String(deserializer);
    var var_encryptedKeyAlg = sse_decode_String(deserializer);
    var var_encryptedFileName = sse_decode_opt_String(deserializer);
    var var_partList = sse_decode_list_file_part_list_item(deserializer);
    return FileData(
        fileId: var_fileId,
        masterKeyId: var_masterKeyId,
        owner: var_owner,
        belongsTo: var_belongsTo,
        belongsToType: var_belongsToType,
        encryptedKey: var_encryptedKey,
        encryptedKeyAlg: var_encryptedKeyAlg,
        encryptedFileName: var_encryptedFileName,
        partList: var_partList);
  }

  @protected
  FileDoneRegister sse_decode_file_done_register(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fileId = sse_decode_String(deserializer);
    var var_sessionId = sse_decode_String(deserializer);
    return FileDoneRegister(fileId: var_fileId, sessionId: var_sessionId);
  }

  @protected
  FileDownloadResult sse_decode_file_download_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nextFileKey = sse_decode_String(deserializer);
    var var_file = sse_decode_list_prim_u_8_strict(deserializer);
    return FileDownloadResult(nextFileKey: var_nextFileKey, file: var_file);
  }

  @protected
  FilePartListItem sse_decode_file_part_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_partId = sse_decode_String(deserializer);
    var var_sequence = sse_decode_i_32(deserializer);
    var var_externStorage = sse_decode_bool(deserializer);
    return FilePartListItem(
        partId: var_partId,
        sequence: var_sequence,
        externStorage: var_externStorage);
  }

  @protected
  FilePrepareRegister sse_decode_file_prepare_register(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_encryptedFileName = sse_decode_opt_String(deserializer);
    var var_serverInput = sse_decode_String(deserializer);
    return FilePrepareRegister(
        encryptedFileName: var_encryptedFileName, serverInput: var_serverInput);
  }

  @protected
  FileRegisterOutput sse_decode_file_register_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fileId = sse_decode_String(deserializer);
    var var_sessionId = sse_decode_String(deserializer);
    var var_encryptedFileName = sse_decode_opt_String(deserializer);
    return FileRegisterOutput(
        fileId: var_fileId,
        sessionId: var_sessionId,
        encryptedFileName: var_encryptedFileName);
  }

  @protected
  GeneratedRegisterData sse_decode_generated_register_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_identifier = sse_decode_String(deserializer);
    var var_password = sse_decode_String(deserializer);
    return GeneratedRegisterData(
        identifier: var_identifier, password: var_password);
  }

  @protected
  GroupChildrenList sse_decode_group_children_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_parent = sse_decode_opt_String(deserializer);
    return GroupChildrenList(
        groupId: var_groupId, time: var_time, parent: var_parent);
  }

  @protected
  GroupDataCheckUpdateServerOutput
      sse_decode_group_data_check_update_server_output(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_keyUpdate = sse_decode_bool(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    return GroupDataCheckUpdateServerOutput(
        keyUpdate: var_keyUpdate, rank: var_rank);
  }

  @protected
  GroupInviteReqList sse_decode_group_invite_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    return GroupInviteReqList(groupId: var_groupId, time: var_time);
  }

  @protected
  GroupJoinReqList sse_decode_group_join_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_userType = sse_decode_i_32(deserializer);
    return GroupJoinReqList(
        userId: var_userId, time: var_time, userType: var_userType);
  }

  @protected
  GroupKeyData sse_decode_group_key_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateGroupKey = sse_decode_String(deserializer);
    var var_publicGroupKey = sse_decode_String(deserializer);
    var var_exportedPublicKey = sse_decode_String(deserializer);
    var var_groupKey = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_groupKeyId = sse_decode_String(deserializer);
    return GroupKeyData(
        privateGroupKey: var_privateGroupKey,
        publicGroupKey: var_publicGroupKey,
        exportedPublicKey: var_exportedPublicKey,
        groupKey: var_groupKey,
        time: var_time,
        groupKeyId: var_groupKeyId);
  }

  @protected
  GroupOutData sse_decode_group_out_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_parentGroupId = sse_decode_opt_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_keyUpdate = sse_decode_bool(deserializer);
    var var_createdTime = sse_decode_String(deserializer);
    var var_joinedTime = sse_decode_String(deserializer);
    var var_keys = sse_decode_list_group_out_data_keys(deserializer);
    var var_hmacKeys = sse_decode_list_group_out_data_hmac_keys(deserializer);
    var var_sortableKeys =
        sse_decode_list_group_out_data_sortable_keys(deserializer);
    var var_accessByGroupAsMember = sse_decode_opt_String(deserializer);
    var var_accessByParentGroup = sse_decode_opt_String(deserializer);
    var var_isConnectedGroup = sse_decode_bool(deserializer);
    return GroupOutData(
        groupId: var_groupId,
        parentGroupId: var_parentGroupId,
        rank: var_rank,
        keyUpdate: var_keyUpdate,
        createdTime: var_createdTime,
        joinedTime: var_joinedTime,
        keys: var_keys,
        hmacKeys: var_hmacKeys,
        sortableKeys: var_sortableKeys,
        accessByGroupAsMember: var_accessByGroupAsMember,
        accessByParentGroup: var_accessByParentGroup,
        isConnectedGroup: var_isConnectedGroup);
  }

  @protected
  GroupOutDataHmacKeys sse_decode_group_out_data_hmac_keys(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupKeyId = sse_decode_String(deserializer);
    var var_keyData = sse_decode_String(deserializer);
    return GroupOutDataHmacKeys(
        groupKeyId: var_groupKeyId, keyData: var_keyData);
  }

  @protected
  GroupOutDataKeys sse_decode_group_out_data_keys(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKeyId = sse_decode_String(deserializer);
    var var_keyData = sse_decode_String(deserializer);
    var var_signedByUserId = sse_decode_opt_String(deserializer);
    var var_signedByUserSignKeyId = sse_decode_opt_String(deserializer);
    return GroupOutDataKeys(
        privateKeyId: var_privateKeyId,
        keyData: var_keyData,
        signedByUserId: var_signedByUserId,
        signedByUserSignKeyId: var_signedByUserSignKeyId);
  }

  @protected
  GroupOutDataSortableKeys sse_decode_group_out_data_sortable_keys(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupKeyId = sse_decode_String(deserializer);
    var var_keyData = sse_decode_String(deserializer);
    return GroupOutDataSortableKeys(
        groupKeyId: var_groupKeyId, keyData: var_keyData);
  }

  @protected
  GroupPublicKeyData sse_decode_group_public_key_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicKey = sse_decode_String(deserializer);
    var var_publicKeyId = sse_decode_String(deserializer);
    return GroupPublicKeyData(
        publicKey: var_publicKey, publicKeyId: var_publicKeyId);
  }

  @protected
  GroupUserListItem sse_decode_group_user_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_userId = sse_decode_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_joinedTime = sse_decode_String(deserializer);
    var var_userType = sse_decode_i_32(deserializer);
    return GroupUserListItem(
        userId: var_userId,
        rank: var_rank,
        joinedTime: var_joinedTime,
        userType: var_userType);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  KeyRotationGetOut sse_decode_key_rotation_get_out(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_preGroupKeyId = sse_decode_String(deserializer);
    var var_newGroupKeyId = sse_decode_String(deserializer);
    var var_encryptedEphKeyKeyId = sse_decode_String(deserializer);
    var var_serverOutput = sse_decode_String(deserializer);
    return KeyRotationGetOut(
        preGroupKeyId: var_preGroupKeyId,
        newGroupKeyId: var_newGroupKeyId,
        encryptedEphKeyKeyId: var_encryptedEphKeyKeyId,
        serverOutput: var_serverOutput);
  }

  @protected
  KeyRotationInput sse_decode_key_rotation_input(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_error = sse_decode_opt_String(deserializer);
    var var_encryptedEphemeralKeyByGroupKeyAndPublicKey =
        sse_decode_String(deserializer);
    var var_encryptedGroupKeyByEphemeral = sse_decode_String(deserializer);
    var var_ephemeralAlg = sse_decode_String(deserializer);
    var var_encryptedEphKeyKeyId = sse_decode_String(deserializer);
    var var_previousGroupKeyId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_newGroupKeyId = sse_decode_String(deserializer);
    return KeyRotationInput(
        error: var_error,
        encryptedEphemeralKeyByGroupKeyAndPublicKey:
            var_encryptedEphemeralKeyByGroupKeyAndPublicKey,
        encryptedGroupKeyByEphemeral: var_encryptedGroupKeyByEphemeral,
        ephemeralAlg: var_ephemeralAlg,
        encryptedEphKeyKeyId: var_encryptedEphKeyKeyId,
        previousGroupKeyId: var_previousGroupKeyId,
        time: var_time,
        newGroupKeyId: var_newGroupKeyId);
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<FilePartListItem> sse_decode_list_file_part_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <FilePartListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_file_part_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupChildrenList> sse_decode_list_group_children_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupChildrenList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_children_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupInviteReqList> sse_decode_list_group_invite_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupInviteReqList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_invite_req_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupJoinReqList> sse_decode_list_group_join_req_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupJoinReqList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_join_req_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupOutDataHmacKeys> sse_decode_list_group_out_data_hmac_keys(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupOutDataHmacKeys>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_out_data_hmac_keys(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupOutDataKeys> sse_decode_list_group_out_data_keys(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupOutDataKeys>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_out_data_keys(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupOutDataSortableKeys> sse_decode_list_group_out_data_sortable_keys(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupOutDataSortableKeys>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_out_data_sortable_keys(deserializer));
    }
    return ans_;
  }

  @protected
  List<GroupUserListItem> sse_decode_list_group_user_list_item(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GroupUserListItem>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_group_user_list_item(deserializer));
    }
    return ans_;
  }

  @protected
  ListGroups sse_decode_list_groups(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_groupId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_joinedTime = sse_decode_String(deserializer);
    var var_rank = sse_decode_i_32(deserializer);
    var var_parent = sse_decode_opt_String(deserializer);
    return ListGroups(
        groupId: var_groupId,
        time: var_time,
        joinedTime: var_joinedTime,
        rank: var_rank,
        parent: var_parent);
  }

  @protected
  List<KeyRotationGetOut> sse_decode_list_key_rotation_get_out(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <KeyRotationGetOut>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_key_rotation_get_out(deserializer));
    }
    return ans_;
  }

  @protected
  List<ListGroups> sse_decode_list_list_groups(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ListGroups>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_list_groups(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<UserDeviceList> sse_decode_list_user_device_list(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <UserDeviceList>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_user_device_list(deserializer));
    }
    return ans_;
  }

  @protected
  List<UserKeyData> sse_decode_list_user_key_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <UserKeyData>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_user_key_data(deserializer));
    }
    return ans_;
  }

  @protected
  NonRegisteredKeyOutput sse_decode_non_registered_key_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_key = sse_decode_String(deserializer);
    var var_encryptedKey = sse_decode_String(deserializer);
    return NonRegisteredKeyOutput(key: var_key, encryptedKey: var_encryptedKey);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OtpRecoveryKeysOutput sse_decode_otp_recovery_keys_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_keys = sse_decode_list_String(deserializer);
    return OtpRecoveryKeysOutput(keys: var_keys);
  }

  @protected
  OtpRegister sse_decode_otp_register(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_secret = sse_decode_String(deserializer);
    var var_alg = sse_decode_String(deserializer);
    var var_recover = sse_decode_list_String(deserializer);
    return OtpRegister(secret: var_secret, alg: var_alg, recover: var_recover);
  }

  @protected
  OtpRegisterUrl sse_decode_otp_register_url(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_recover = sse_decode_list_String(deserializer);
    return OtpRegisterUrl(url: var_url, recover: var_recover);
  }

  @protected
  PreRegisterDeviceData sse_decode_pre_register_device_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_input = sse_decode_String(deserializer);
    var var_exportedPublicKey = sse_decode_String(deserializer);
    return PreRegisterDeviceData(
        input: var_input, exportedPublicKey: var_exportedPublicKey);
  }

  @protected
  RegisterDeviceData sse_decode_register_device_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sessionId = sse_decode_String(deserializer);
    var var_exportedPublicKey = sse_decode_String(deserializer);
    return RegisterDeviceData(
        sessionId: var_sessionId, exportedPublicKey: var_exportedPublicKey);
  }

  @protected
  SearchableCreateOutput sse_decode_searchable_create_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hashes = sse_decode_list_String(deserializer);
    var var_alg = sse_decode_String(deserializer);
    var var_keyId = sse_decode_String(deserializer);
    return SearchableCreateOutput(
        hashes: var_hashes, alg: var_alg, keyId: var_keyId);
  }

  @protected
  SortableEncryptOutput sse_decode_sortable_encrypt_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_number = sse_decode_u_64(deserializer);
    var var_alg = sse_decode_String(deserializer);
    var var_keyId = sse_decode_String(deserializer);
    return SortableEncryptOutput(
        number: var_number, alg: var_alg, keyId: var_keyId);
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserData sse_decode_user_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_jwt = sse_decode_String(deserializer);
    var var_userId = sse_decode_String(deserializer);
    var var_deviceId = sse_decode_String(deserializer);
    var var_refreshToken = sse_decode_String(deserializer);
    var var_keys = sse_decode_device_key_data(deserializer);
    var var_userKeys = sse_decode_list_user_key_data(deserializer);
    var var_hmacKeys = sse_decode_list_group_out_data_hmac_keys(deserializer);
    return UserData(
        jwt: var_jwt,
        userId: var_userId,
        deviceId: var_deviceId,
        refreshToken: var_refreshToken,
        keys: var_keys,
        userKeys: var_userKeys,
        hmacKeys: var_hmacKeys);
  }

  @protected
  UserDeviceList sse_decode_user_device_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_deviceId = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_deviceIdentifier = sse_decode_String(deserializer);
    return UserDeviceList(
        deviceId: var_deviceId,
        time: var_time,
        deviceIdentifier: var_deviceIdentifier);
  }

  @protected
  UserInitServerOutput sse_decode_user_init_server_output(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_jwt = sse_decode_String(deserializer);
    var var_invites = sse_decode_list_group_invite_req_list(deserializer);
    return UserInitServerOutput(jwt: var_jwt, invites: var_invites);
  }

  @protected
  UserKeyData sse_decode_user_key_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_privateKey = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    var var_groupKey = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_groupKeyId = sse_decode_String(deserializer);
    var var_signKey = sse_decode_String(deserializer);
    var var_verifyKey = sse_decode_String(deserializer);
    var var_exportedPublicKey = sse_decode_String(deserializer);
    var var_exportedPublicKeySigKeyId = sse_decode_opt_String(deserializer);
    var var_exportedVerifyKey = sse_decode_String(deserializer);
    return UserKeyData(
        privateKey: var_privateKey,
        publicKey: var_publicKey,
        groupKey: var_groupKey,
        time: var_time,
        groupKeyId: var_groupKeyId,
        signKey: var_signKey,
        verifyKey: var_verifyKey,
        exportedPublicKey: var_exportedPublicKey,
        exportedPublicKeySigKeyId: var_exportedPublicKeySigKeyId,
        exportedVerifyKey: var_exportedVerifyKey);
  }

  @protected
  UserLoginOut sse_decode_user_login_out(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_direct = sse_decode_opt_String(deserializer);
    var var_masterKey = sse_decode_opt_String(deserializer);
    var var_authKey = sse_decode_opt_String(deserializer);
    return UserLoginOut(
        direct: var_direct, masterKey: var_masterKey, authKey: var_authKey);
  }

  @protected
  UserPublicKeyData sse_decode_user_public_key_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_publicKey = sse_decode_String(deserializer);
    var var_publicKeyId = sse_decode_String(deserializer);
    var var_publicKeySigKeyId = sse_decode_opt_String(deserializer);
    return UserPublicKeyData(
        publicKey: var_publicKey,
        publicKeyId: var_publicKeyId,
        publicKeySigKeyId: var_publicKeySigKeyId);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int cst_encode_belongs_to_type(BelongsToType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_belongs_to_type(
      BelongsToType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_claims(Claims self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.aud, serializer);
    sse_encode_String(self.sub, serializer);
    sse_encode_usize(self.exp, serializer);
    sse_encode_usize(self.iat, serializer);
    sse_encode_bool(self.fresh, serializer);
  }

  @protected
  void sse_encode_crypto_raw_output(
      CryptoRawOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.head, serializer);
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_device_key_data(
      DeviceKeyData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.privateKey, serializer);
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.signKey, serializer);
    sse_encode_String(self.verifyKey, serializer);
    sse_encode_String(self.exportedPublicKey, serializer);
    sse_encode_String(self.exportedVerifyKey, serializer);
  }

  @protected
  void sse_encode_encrypted_head(EncryptedHead self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_opt_String(self.signId, serializer);
    sse_encode_opt_String(self.signAlg, serializer);
  }

  @protected
  void sse_encode_file_data(FileData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.fileId, serializer);
    sse_encode_String(self.masterKeyId, serializer);
    sse_encode_String(self.owner, serializer);
    sse_encode_opt_String(self.belongsTo, serializer);
    sse_encode_belongs_to_type(self.belongsToType, serializer);
    sse_encode_String(self.encryptedKey, serializer);
    sse_encode_String(self.encryptedKeyAlg, serializer);
    sse_encode_opt_String(self.encryptedFileName, serializer);
    sse_encode_list_file_part_list_item(self.partList, serializer);
  }

  @protected
  void sse_encode_file_done_register(
      FileDoneRegister self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.fileId, serializer);
    sse_encode_String(self.sessionId, serializer);
  }

  @protected
  void sse_encode_file_download_result(
      FileDownloadResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.nextFileKey, serializer);
    sse_encode_list_prim_u_8_strict(self.file, serializer);
  }

  @protected
  void sse_encode_file_part_list_item(
      FilePartListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.partId, serializer);
    sse_encode_i_32(self.sequence, serializer);
    sse_encode_bool(self.externStorage, serializer);
  }

  @protected
  void sse_encode_file_prepare_register(
      FilePrepareRegister self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.encryptedFileName, serializer);
    sse_encode_String(self.serverInput, serializer);
  }

  @protected
  void sse_encode_file_register_output(
      FileRegisterOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.fileId, serializer);
    sse_encode_String(self.sessionId, serializer);
    sse_encode_opt_String(self.encryptedFileName, serializer);
  }

  @protected
  void sse_encode_generated_register_data(
      GeneratedRegisterData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.identifier, serializer);
    sse_encode_String(self.password, serializer);
  }

  @protected
  void sse_encode_group_children_list(
      GroupChildrenList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_opt_String(self.parent, serializer);
  }

  @protected
  void sse_encode_group_data_check_update_server_output(
      GroupDataCheckUpdateServerOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.keyUpdate, serializer);
    sse_encode_i_32(self.rank, serializer);
  }

  @protected
  void sse_encode_group_invite_req_list(
      GroupInviteReqList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_String(self.time, serializer);
  }

  @protected
  void sse_encode_group_join_req_list(
      GroupJoinReqList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_i_32(self.userType, serializer);
  }

  @protected
  void sse_encode_group_key_data(GroupKeyData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.privateGroupKey, serializer);
    sse_encode_String(self.publicGroupKey, serializer);
    sse_encode_String(self.exportedPublicKey, serializer);
    sse_encode_String(self.groupKey, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.groupKeyId, serializer);
  }

  @protected
  void sse_encode_group_out_data(GroupOutData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_opt_String(self.parentGroupId, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_bool(self.keyUpdate, serializer);
    sse_encode_String(self.createdTime, serializer);
    sse_encode_String(self.joinedTime, serializer);
    sse_encode_list_group_out_data_keys(self.keys, serializer);
    sse_encode_list_group_out_data_hmac_keys(self.hmacKeys, serializer);
    sse_encode_list_group_out_data_sortable_keys(self.sortableKeys, serializer);
    sse_encode_opt_String(self.accessByGroupAsMember, serializer);
    sse_encode_opt_String(self.accessByParentGroup, serializer);
    sse_encode_bool(self.isConnectedGroup, serializer);
  }

  @protected
  void sse_encode_group_out_data_hmac_keys(
      GroupOutDataHmacKeys self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupKeyId, serializer);
    sse_encode_String(self.keyData, serializer);
  }

  @protected
  void sse_encode_group_out_data_keys(
      GroupOutDataKeys self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.privateKeyId, serializer);
    sse_encode_String(self.keyData, serializer);
    sse_encode_opt_String(self.signedByUserId, serializer);
    sse_encode_opt_String(self.signedByUserSignKeyId, serializer);
  }

  @protected
  void sse_encode_group_out_data_sortable_keys(
      GroupOutDataSortableKeys self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupKeyId, serializer);
    sse_encode_String(self.keyData, serializer);
  }

  @protected
  void sse_encode_group_public_key_data(
      GroupPublicKeyData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.publicKeyId, serializer);
  }

  @protected
  void sse_encode_group_user_list_item(
      GroupUserListItem self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.userId, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_String(self.joinedTime, serializer);
    sse_encode_i_32(self.userType, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_key_rotation_get_out(
      KeyRotationGetOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.preGroupKeyId, serializer);
    sse_encode_String(self.newGroupKeyId, serializer);
    sse_encode_String(self.encryptedEphKeyKeyId, serializer);
    sse_encode_String(self.serverOutput, serializer);
  }

  @protected
  void sse_encode_key_rotation_input(
      KeyRotationInput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.error, serializer);
    sse_encode_String(
        self.encryptedEphemeralKeyByGroupKeyAndPublicKey, serializer);
    sse_encode_String(self.encryptedGroupKeyByEphemeral, serializer);
    sse_encode_String(self.ephemeralAlg, serializer);
    sse_encode_String(self.encryptedEphKeyKeyId, serializer);
    sse_encode_String(self.previousGroupKeyId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.newGroupKeyId, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_file_part_list_item(
      List<FilePartListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_file_part_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_children_list(
      List<GroupChildrenList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_children_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_invite_req_list(
      List<GroupInviteReqList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_invite_req_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_join_req_list(
      List<GroupJoinReqList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_join_req_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_out_data_hmac_keys(
      List<GroupOutDataHmacKeys> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_out_data_hmac_keys(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_out_data_keys(
      List<GroupOutDataKeys> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_out_data_keys(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_out_data_sortable_keys(
      List<GroupOutDataSortableKeys> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_out_data_sortable_keys(item, serializer);
    }
  }

  @protected
  void sse_encode_list_group_user_list_item(
      List<GroupUserListItem> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_group_user_list_item(item, serializer);
    }
  }

  @protected
  void sse_encode_list_groups(ListGroups self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.groupId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.joinedTime, serializer);
    sse_encode_i_32(self.rank, serializer);
    sse_encode_opt_String(self.parent, serializer);
  }

  @protected
  void sse_encode_list_key_rotation_get_out(
      List<KeyRotationGetOut> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_key_rotation_get_out(item, serializer);
    }
  }

  @protected
  void sse_encode_list_list_groups(
      List<ListGroups> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_list_groups(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_user_device_list(
      List<UserDeviceList> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_user_device_list(item, serializer);
    }
  }

  @protected
  void sse_encode_list_user_key_data(
      List<UserKeyData> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_user_key_data(item, serializer);
    }
  }

  @protected
  void sse_encode_non_registered_key_output(
      NonRegisteredKeyOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.key, serializer);
    sse_encode_String(self.encryptedKey, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_otp_recovery_keys_output(
      OtpRecoveryKeysOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.keys, serializer);
  }

  @protected
  void sse_encode_otp_register(OtpRegister self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.secret, serializer);
    sse_encode_String(self.alg, serializer);
    sse_encode_list_String(self.recover, serializer);
  }

  @protected
  void sse_encode_otp_register_url(
      OtpRegisterUrl self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_list_String(self.recover, serializer);
  }

  @protected
  void sse_encode_pre_register_device_data(
      PreRegisterDeviceData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.input, serializer);
    sse_encode_String(self.exportedPublicKey, serializer);
  }

  @protected
  void sse_encode_register_device_data(
      RegisterDeviceData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sessionId, serializer);
    sse_encode_String(self.exportedPublicKey, serializer);
  }

  @protected
  void sse_encode_searchable_create_output(
      SearchableCreateOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.hashes, serializer);
    sse_encode_String(self.alg, serializer);
    sse_encode_String(self.keyId, serializer);
  }

  @protected
  void sse_encode_sortable_encrypt_output(
      SortableEncryptOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.number, serializer);
    sse_encode_String(self.alg, serializer);
    sse_encode_String(self.keyId, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_data(UserData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.jwt, serializer);
    sse_encode_String(self.userId, serializer);
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.refreshToken, serializer);
    sse_encode_device_key_data(self.keys, serializer);
    sse_encode_list_user_key_data(self.userKeys, serializer);
    sse_encode_list_group_out_data_hmac_keys(self.hmacKeys, serializer);
  }

  @protected
  void sse_encode_user_device_list(
      UserDeviceList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.deviceId, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.deviceIdentifier, serializer);
  }

  @protected
  void sse_encode_user_init_server_output(
      UserInitServerOutput self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.jwt, serializer);
    sse_encode_list_group_invite_req_list(self.invites, serializer);
  }

  @protected
  void sse_encode_user_key_data(UserKeyData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.privateKey, serializer);
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.groupKey, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.groupKeyId, serializer);
    sse_encode_String(self.signKey, serializer);
    sse_encode_String(self.verifyKey, serializer);
    sse_encode_String(self.exportedPublicKey, serializer);
    sse_encode_opt_String(self.exportedPublicKeySigKeyId, serializer);
    sse_encode_String(self.exportedVerifyKey, serializer);
  }

  @protected
  void sse_encode_user_login_out(UserLoginOut self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.direct, serializer);
    sse_encode_opt_String(self.masterKey, serializer);
    sse_encode_opt_String(self.authKey, serializer);
  }

  @protected
  void sse_encode_user_public_key_data(
      UserPublicKeyData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.publicKey, serializer);
    sse_encode_String(self.publicKeyId, serializer);
    sse_encode_opt_String(self.publicKeySigKeyId, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
