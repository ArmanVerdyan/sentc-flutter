// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`

Future<FileData> fileDownloadFileMeta(
        {required String baseUrl,
        required String authToken,
        String? jwt,
        required String id,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiFileFileDownloadFileMeta(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<FileDownloadResult> fileDownloadAndDecryptFilePartStart(
        {required String baseUrl,
        String? urlPrefix,
        required String authToken,
        required String partId,
        required String contentKey,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiFileFileDownloadAndDecryptFilePartStart(
        baseUrl: baseUrl,
        urlPrefix: urlPrefix,
        authToken: authToken,
        partId: partId,
        contentKey: contentKey,
        verifyKeyData: verifyKeyData);

Future<FileDownloadResult> fileDownloadAndDecryptFilePart(
        {required String baseUrl,
        String? urlPrefix,
        required String authToken,
        required String partId,
        required String contentKey,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiFileFileDownloadAndDecryptFilePart(
        baseUrl: baseUrl,
        urlPrefix: urlPrefix,
        authToken: authToken,
        partId: partId,
        contentKey: contentKey,
        verifyKeyData: verifyKeyData);

Future<List<FilePartListItem>> fileDownloadPartList(
        {required String baseUrl,
        required String authToken,
        required String fileId,
        required String lastSequence}) =>
    RustLib.instance.api.crateApiFileFileDownloadPartList(
        baseUrl: baseUrl,
        authToken: authToken,
        fileId: fileId,
        lastSequence: lastSequence);

Future<FileRegisterOutput> fileRegisterFile(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String masterKeyId,
        required String contentKey,
        required String encryptedContentKey,
        String? belongsToId,
        required String belongsToType,
        String? fileName,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiFileFileRegisterFile(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        masterKeyId: masterKeyId,
        contentKey: contentKey,
        encryptedContentKey: encryptedContentKey,
        belongsToId: belongsToId,
        belongsToType: belongsToType,
        fileName: fileName,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<FilePrepareRegister> filePrepareRegisterFile(
        {required String masterKeyId,
        required String contentKey,
        required String encryptedContentKey,
        String? belongsToId,
        required String belongsToType,
        String? fileName}) =>
    RustLib.instance.api.crateApiFileFilePrepareRegisterFile(
        masterKeyId: masterKeyId,
        contentKey: contentKey,
        encryptedContentKey: encryptedContentKey,
        belongsToId: belongsToId,
        belongsToType: belongsToType,
        fileName: fileName);

Future<FileDoneRegister> fileDoneRegisterFile({required String serverOutput}) =>
    RustLib.instance.api
        .crateApiFileFileDoneRegisterFile(serverOutput: serverOutput);

Future<String> fileUploadPartStart(
        {required String baseUrl,
        String? urlPrefix,
        required String authToken,
        required String jwt,
        required String sessionId,
        required bool end,
        required int sequence,
        required String contentKey,
        String? signKey,
        required List<int> part_}) =>
    RustLib.instance.api.crateApiFileFileUploadPartStart(
        baseUrl: baseUrl,
        urlPrefix: urlPrefix,
        authToken: authToken,
        jwt: jwt,
        sessionId: sessionId,
        end: end,
        sequence: sequence,
        contentKey: contentKey,
        signKey: signKey,
        part_: part_);

Future<String> fileUploadPart(
        {required String baseUrl,
        String? urlPrefix,
        required String authToken,
        required String jwt,
        required String sessionId,
        required bool end,
        required int sequence,
        required String contentKey,
        String? signKey,
        required List<int> part_}) =>
    RustLib.instance.api.crateApiFileFileUploadPart(
        baseUrl: baseUrl,
        urlPrefix: urlPrefix,
        authToken: authToken,
        jwt: jwt,
        sessionId: sessionId,
        end: end,
        sequence: sequence,
        contentKey: contentKey,
        signKey: signKey,
        part_: part_);

Future<void> fileFileNameUpdate(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String fileId,
        required String contentKey,
        String? fileName}) =>
    RustLib.instance.api.crateApiFileFileFileNameUpdate(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        fileId: fileId,
        contentKey: contentKey,
        fileName: fileName);

Future<void> fileDeleteFile(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String fileId,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiFileFileDeleteFile(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        fileId: fileId,
        groupId: groupId,
        groupAsMember: groupAsMember);

enum BelongsToType {
  group,
  user,
  none,
  ;
}

class FileData {
  final String fileId;
  final String masterKeyId;
  final String owner;
  final String? belongsTo;
  final BelongsToType belongsToType;
  final String encryptedKey;
  final String encryptedKeyAlg;
  final String? encryptedFileName;
  final List<FilePartListItem> partList;

  const FileData({
    required this.fileId,
    required this.masterKeyId,
    required this.owner,
    this.belongsTo,
    required this.belongsToType,
    required this.encryptedKey,
    required this.encryptedKeyAlg,
    this.encryptedFileName,
    required this.partList,
  });

  @override
  int get hashCode =>
      fileId.hashCode ^
      masterKeyId.hashCode ^
      owner.hashCode ^
      belongsTo.hashCode ^
      belongsToType.hashCode ^
      encryptedKey.hashCode ^
      encryptedKeyAlg.hashCode ^
      encryptedFileName.hashCode ^
      partList.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileData &&
          runtimeType == other.runtimeType &&
          fileId == other.fileId &&
          masterKeyId == other.masterKeyId &&
          owner == other.owner &&
          belongsTo == other.belongsTo &&
          belongsToType == other.belongsToType &&
          encryptedKey == other.encryptedKey &&
          encryptedKeyAlg == other.encryptedKeyAlg &&
          encryptedFileName == other.encryptedFileName &&
          partList == other.partList;
}

class FileDoneRegister {
  final String fileId;
  final String sessionId;

  const FileDoneRegister({
    required this.fileId,
    required this.sessionId,
  });

  @override
  int get hashCode => fileId.hashCode ^ sessionId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileDoneRegister &&
          runtimeType == other.runtimeType &&
          fileId == other.fileId &&
          sessionId == other.sessionId;
}

class FileDownloadResult {
  final String nextFileKey;
  final Uint8List file;

  const FileDownloadResult({
    required this.nextFileKey,
    required this.file,
  });

  @override
  int get hashCode => nextFileKey.hashCode ^ file.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileDownloadResult &&
          runtimeType == other.runtimeType &&
          nextFileKey == other.nextFileKey &&
          file == other.file;
}

class FilePartListItem {
  final String partId;
  final int sequence;
  final bool externStorage;

  const FilePartListItem({
    required this.partId,
    required this.sequence,
    required this.externStorage,
  });

  @override
  int get hashCode =>
      partId.hashCode ^ sequence.hashCode ^ externStorage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilePartListItem &&
          runtimeType == other.runtimeType &&
          partId == other.partId &&
          sequence == other.sequence &&
          externStorage == other.externStorage;
}

class FilePrepareRegister {
  final String? encryptedFileName;
  final String serverInput;

  const FilePrepareRegister({
    this.encryptedFileName,
    required this.serverInput,
  });

  @override
  int get hashCode => encryptedFileName.hashCode ^ serverInput.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilePrepareRegister &&
          runtimeType == other.runtimeType &&
          encryptedFileName == other.encryptedFileName &&
          serverInput == other.serverInput;
}

class FileRegisterOutput {
  final String fileId;
  final String sessionId;
  final String? encryptedFileName;

  const FileRegisterOutput({
    required this.fileId,
    required this.sessionId,
    this.encryptedFileName,
  });

  @override
  int get hashCode =>
      fileId.hashCode ^ sessionId.hashCode ^ encryptedFileName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileRegisterOutput &&
          runtimeType == other.runtimeType &&
          fileId == other.fileId &&
          sessionId == other.sessionId &&
          encryptedFileName == other.encryptedFileName;
}
