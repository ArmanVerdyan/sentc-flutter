// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`

Future<EncryptedHead> splitHeadAndEncryptedData({required List<int> data}) =>
    RustLib.instance.api.crateApiCryptoSplitHeadAndEncryptedData(data: data);

Future<EncryptedHead> splitHeadAndEncryptedString({required String data}) =>
    RustLib.instance.api.crateApiCryptoSplitHeadAndEncryptedString(data: data);

Future<EncryptedHead> deserializeHeadFromString({required String head}) =>
    RustLib.instance.api.crateApiCryptoDeserializeHeadFromString(head: head);

Future<CryptoRawOutput> encryptRawSymmetric(
        {required String key, required List<int> data, String? signKey}) =>
    RustLib.instance.api.crateApiCryptoEncryptRawSymmetric(
        key: key, data: data, signKey: signKey);

Future<Uint8List> decryptRawSymmetric(
        {required String key,
        required List<int> encryptedData,
        required String head,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiCryptoDecryptRawSymmetric(
        key: key,
        encryptedData: encryptedData,
        head: head,
        verifyKeyData: verifyKeyData);

Future<Uint8List> encryptSymmetric(
        {required String key, required List<int> data, String? signKey}) =>
    RustLib.instance.api
        .crateApiCryptoEncryptSymmetric(key: key, data: data, signKey: signKey);

Future<Uint8List> decryptSymmetric(
        {required String key,
        required List<int> encryptedData,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiCryptoDecryptSymmetric(
        key: key, encryptedData: encryptedData, verifyKeyData: verifyKeyData);

Future<String> encryptStringSymmetric(
        {required String key, required String data, String? signKey}) =>
    RustLib.instance.api.crateApiCryptoEncryptStringSymmetric(
        key: key, data: data, signKey: signKey);

Future<String> decryptStringSymmetric(
        {required String key,
        required String encryptedData,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiCryptoDecryptStringSymmetric(
        key: key, encryptedData: encryptedData, verifyKeyData: verifyKeyData);

Future<CryptoRawOutput> encryptRawAsymmetric(
        {required String replyPublicKeyData,
        required List<int> data,
        String? signKey}) =>
    RustLib.instance.api.crateApiCryptoEncryptRawAsymmetric(
        replyPublicKeyData: replyPublicKeyData, data: data, signKey: signKey);

Future<Uint8List> decryptRawAsymmetric(
        {required String privateKey,
        required List<int> encryptedData,
        required String head,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiCryptoDecryptRawAsymmetric(
        privateKey: privateKey,
        encryptedData: encryptedData,
        head: head,
        verifyKeyData: verifyKeyData);

Future<Uint8List> encryptAsymmetric(
        {required String replyPublicKeyData,
        required List<int> data,
        String? signKey}) =>
    RustLib.instance.api.crateApiCryptoEncryptAsymmetric(
        replyPublicKeyData: replyPublicKeyData, data: data, signKey: signKey);

Future<Uint8List> decryptAsymmetric(
        {required String privateKey,
        required List<int> encryptedData,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiCryptoDecryptAsymmetric(
        privateKey: privateKey,
        encryptedData: encryptedData,
        verifyKeyData: verifyKeyData);

Future<String> encryptStringAsymmetric(
        {required String replyPublicKeyData,
        required String data,
        String? signKey}) =>
    RustLib.instance.api.crateApiCryptoEncryptStringAsymmetric(
        replyPublicKeyData: replyPublicKeyData, data: data, signKey: signKey);

Future<String> decryptStringAsymmetric(
        {required String privateKey,
        required String encryptedData,
        String? verifyKeyData}) =>
    RustLib.instance.api.crateApiCryptoDecryptStringAsymmetric(
        privateKey: privateKey,
        encryptedData: encryptedData,
        verifyKeyData: verifyKeyData);

Future<NonRegisteredKeyOutput> generateNonRegisterSymKey(
        {required String masterKey}) =>
    RustLib.instance.api
        .crateApiCryptoGenerateNonRegisterSymKey(masterKey: masterKey);

Future<NonRegisteredKeyOutput> generateNonRegisterSymKeyByPublicKey(
        {required String replyPublicKey}) =>
    RustLib.instance.api.crateApiCryptoGenerateNonRegisterSymKeyByPublicKey(
        replyPublicKey: replyPublicKey);

Future<String> decryptSymKey(
        {required String masterKey,
        required String encryptedSymmetricKeyInfo}) =>
    RustLib.instance.api.crateApiCryptoDecryptSymKey(
        masterKey: masterKey,
        encryptedSymmetricKeyInfo: encryptedSymmetricKeyInfo);

Future<String> decryptSymKeyByPrivateKey(
        {required String privateKey,
        required String encryptedSymmetricKeyInfo}) =>
    RustLib.instance.api.crateApiCryptoDecryptSymKeyByPrivateKey(
        privateKey: privateKey,
        encryptedSymmetricKeyInfo: encryptedSymmetricKeyInfo);

Future<String> doneFetchSymKey(
        {required String masterKey,
        required String serverOut,
        required bool nonRegistered}) =>
    RustLib.instance.api.crateApiCryptoDoneFetchSymKey(
        masterKey: masterKey,
        serverOut: serverOut,
        nonRegistered: nonRegistered);

Future<String> doneFetchSymKeyByPrivateKey(
        {required String privateKey,
        required String serverOut,
        required bool nonRegistered}) =>
    RustLib.instance.api.crateApiCryptoDoneFetchSymKeyByPrivateKey(
        privateKey: privateKey,
        serverOut: serverOut,
        nonRegistered: nonRegistered);

Future<List<String>> createSearchableRaw(
        {required String key,
        required String data,
        required bool full,
        int? limit}) =>
    RustLib.instance.api.crateApiCryptoCreateSearchableRaw(
        key: key, data: data, full: full, limit: limit);

Future<SearchableCreateOutput> createSearchable(
        {required String key,
        required String data,
        required bool full,
        int? limit}) =>
    RustLib.instance.api.crateApiCryptoCreateSearchable(
        key: key, data: data, full: full, limit: limit);

Future<String> search({required String key, required String data}) =>
    RustLib.instance.api.crateApiCryptoSearch(key: key, data: data);

Future<BigInt> sortableEncryptRawNumber(
        {required String key, required BigInt data}) =>
    RustLib.instance.api
        .crateApiCryptoSortableEncryptRawNumber(key: key, data: data);

Future<SortableEncryptOutput> sortableEncryptNumber(
        {required String key, required BigInt data}) =>
    RustLib.instance.api
        .crateApiCryptoSortableEncryptNumber(key: key, data: data);

Future<BigInt> sortableEncryptRawString(
        {required String key, required String data}) =>
    RustLib.instance.api
        .crateApiCryptoSortableEncryptRawString(key: key, data: data);

Future<SortableEncryptOutput> sortableEncryptString(
        {required String key, required String data}) =>
    RustLib.instance.api
        .crateApiCryptoSortableEncryptString(key: key, data: data);

class CryptoRawOutput {
  final String head;
  final Uint8List data;

  const CryptoRawOutput({
    required this.head,
    required this.data,
  });

  @override
  int get hashCode => head.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CryptoRawOutput &&
          runtimeType == other.runtimeType &&
          head == other.head &&
          data == other.data;
}

class EncryptedHead {
  final String id;
  final String? signId;
  final String? signAlg;

  const EncryptedHead({
    required this.id,
    this.signId,
    this.signAlg,
  });

  @override
  int get hashCode => id.hashCode ^ signId.hashCode ^ signAlg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncryptedHead &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          signId == other.signId &&
          signAlg == other.signAlg;
}

class NonRegisteredKeyOutput {
  final String key;
  final String encryptedKey;

  const NonRegisteredKeyOutput({
    required this.key,
    required this.encryptedKey,
  });

  @override
  int get hashCode => key.hashCode ^ encryptedKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NonRegisteredKeyOutput &&
          runtimeType == other.runtimeType &&
          key == other.key &&
          encryptedKey == other.encryptedKey;
}

class SearchableCreateOutput {
  final List<String> hashes;
  final String alg;
  final String keyId;

  const SearchableCreateOutput({
    required this.hashes,
    required this.alg,
    required this.keyId,
  });

  @override
  int get hashCode => hashes.hashCode ^ alg.hashCode ^ keyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchableCreateOutput &&
          runtimeType == other.runtimeType &&
          hashes == other.hashes &&
          alg == other.alg &&
          keyId == other.keyId;
}

class SortableEncryptOutput {
  final BigInt number;
  final String alg;
  final String keyId;

  const SortableEncryptOutput({
    required this.number,
    required this.alg,
    required this.keyId,
  });

  @override
  int get hashCode => number.hashCode ^ alg.hashCode ^ keyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SortableEncryptOutput &&
          runtimeType == other.runtimeType &&
          number == other.number &&
          alg == other.alg &&
          keyId == other.keyId;
}
