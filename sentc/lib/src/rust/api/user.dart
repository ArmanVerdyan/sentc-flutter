// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'group.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `PrepareLoginOtpOutput`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

Claims decodeJwt({required String jwt}) =>
    RustLib.instance.api.crateApiUserDecodeJwt(jwt: jwt);

///# Check if the identifier is available for this app
///
Future<bool> checkUserIdentifierAvailable(
        {required String baseUrl,
        required String authToken,
        required String userIdentifier}) =>
    RustLib.instance.api.crateApiUserCheckUserIdentifierAvailable(
        baseUrl: baseUrl, authToken: authToken, userIdentifier: userIdentifier);

///# Check if the identifier is available
///
///but without making a request
///
String prepareCheckUserIdentifierAvailable({required String userIdentifier}) =>
    RustLib.instance.api.crateApiUserPrepareCheckUserIdentifierAvailable(
        userIdentifier: userIdentifier);

///# Validates the response if the identifier is available
///
///but without making a request
///
bool doneCheckUserIdentifierAvailable({required String serverOutput}) => RustLib
    .instance.api
    .crateApiUserDoneCheckUserIdentifierAvailable(serverOutput: serverOutput);

///Generates identifier and password for a user or device
Future<GeneratedRegisterData> generateUserRegisterData() =>
    RustLib.instance.api.crateApiUserGenerateUserRegisterData();

///# Get the user input from the user client
///
///This is used when the register endpoint should only be called from the backend and not the clients.
///
///For full-register see register()
///
Future<String> prepareRegister(
        {required String userIdentifier, required String password}) =>
    RustLib.instance.api.crateApiUserPrepareRegister(
        userIdentifier: userIdentifier, password: password);

///# Validates the response of register
///
///Returns the new user id
///
String doneRegister({required String serverOutput}) =>
    RustLib.instance.api.crateApiUserDoneRegister(serverOutput: serverOutput);

///# Register a new user for the app
///
///Do the full req incl. req.
///No checking about spamming and just return the user id.
///
Future<String> register(
        {required String baseUrl,
        required String authToken,
        required String userIdentifier,
        required String password}) =>
    RustLib.instance.api.crateApiUserRegister(
        baseUrl: baseUrl,
        authToken: authToken,
        userIdentifier: userIdentifier,
        password: password);

Future<String> prepareRegisterDeviceStart(
        {required String deviceIdentifier, required String password}) =>
    RustLib.instance.api.crateApiUserPrepareRegisterDeviceStart(
        deviceIdentifier: deviceIdentifier, password: password);

void doneRegisterDeviceStart({required String serverOutput}) =>
    RustLib.instance.api
        .crateApiUserDoneRegisterDeviceStart(serverOutput: serverOutput);

Future<String> registerDeviceStart(
        {required String baseUrl,
        required String authToken,
        required String deviceIdentifier,
        required String password}) =>
    RustLib.instance.api.crateApiUserRegisterDeviceStart(
        baseUrl: baseUrl,
        authToken: authToken,
        deviceIdentifier: deviceIdentifier,
        password: password);

Future<PreRegisterDeviceData> prepareRegisterDevice(
        {required String serverOutput,
        required String userKeys,
        required int keyCount}) =>
    RustLib.instance.api.crateApiUserPrepareRegisterDevice(
        serverOutput: serverOutput, userKeys: userKeys, keyCount: keyCount);

Future<RegisterDeviceData> registerDevice(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String serverOutput,
        required int keyCount,
        required String userKeys}) =>
    RustLib.instance.api.crateApiUserRegisterDevice(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        serverOutput: serverOutput,
        keyCount: keyCount,
        userKeys: userKeys);

Future<void> userDeviceKeySessionUpload(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String sessionId,
        required String userPublicKey,
        required String groupKeys}) =>
    RustLib.instance.api.crateApiUserUserDeviceKeySessionUpload(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        sessionId: sessionId,
        userPublicKey: userPublicKey,
        groupKeys: groupKeys);

///# Log in the user to this app
///
///Does the login requests. 1. for auth, 2nd to get the keys.
///
///If there is more data in the backend, then it is possible to call it via the jwt what is returned by the done login request.
///
///The other backend can validate the jwt
///
Future<UserLoginOut> login(
        {required String baseUrl,
        required String authToken,
        required String userIdentifier,
        required String password}) =>
    RustLib.instance.api.crateApiUserLogin(
        baseUrl: baseUrl,
        authToken: authToken,
        userIdentifier: userIdentifier,
        password: password);

Future<UserData> extractUserData({required String data}) =>
    RustLib.instance.api.crateApiUserExtractUserData(data: data);

Future<UserData> mfaLogin(
        {required String baseUrl,
        required String authToken,
        required String masterKeyEncryption,
        required String authKey,
        required String userIdentifier,
        required String token,
        required bool recovery}) =>
    RustLib.instance.api.crateApiUserMfaLogin(
        baseUrl: baseUrl,
        authToken: authToken,
        masterKeyEncryption: masterKeyEncryption,
        authKey: authKey,
        userIdentifier: userIdentifier,
        token: token,
        recovery: recovery);

Future<UserKeyData> doneFetchUserKey(
        {required String privateKey, required String serverOutput}) =>
    RustLib.instance.api.crateApiUserDoneFetchUserKey(
        privateKey: privateKey, serverOutput: serverOutput);

Future<UserKeyData> fetchUserKey(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String keyId,
        required String privateKey}) =>
    RustLib.instance.api.crateApiUserFetchUserKey(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        keyId: keyId,
        privateKey: privateKey);

Future<String> getFreshJwt(
        {required String baseUrl,
        required String authToken,
        required String userIdentifier,
        required String password,
        String? mfaToken,
        bool? mfaRecovery}) =>
    RustLib.instance.api.crateApiUserGetFreshJwt(
        baseUrl: baseUrl,
        authToken: authToken,
        userIdentifier: userIdentifier,
        password: password,
        mfaToken: mfaToken,
        mfaRecovery: mfaRecovery);

Future<String> refreshJwt(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String refreshToken}) =>
    RustLib.instance.api.crateApiUserRefreshJwt(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        refreshToken: refreshToken);

Future<UserInitServerOutput> initUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String refreshToken}) =>
    RustLib.instance.api.crateApiUserInitUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        refreshToken: refreshToken);

Future<String> userCreateSafetyNumber(
        {required String verifyKey1,
        required String userId1,
        String? verifyKey2,
        String? userId2}) =>
    RustLib.instance.api.crateApiUserUserCreateSafetyNumber(
        verifyKey1: verifyKey1,
        userId1: userId1,
        verifyKey2: verifyKey2,
        userId2: userId2);

Future<bool> userVerifyUserPublicKey(
        {required String verifyKey, required String publicKey}) =>
    RustLib.instance.api.crateApiUserUserVerifyUserPublicKey(
        verifyKey: verifyKey, publicKey: publicKey);

Future<List<UserDeviceList>> getUserDevices(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedId}) =>
    RustLib.instance.api.crateApiUserGetUserDevices(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedId: lastFetchedId);

Future<void> resetPassword(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String newPassword,
        required String decryptedPrivateKey,
        required String decryptedSignKey}) =>
    RustLib.instance.api.crateApiUserResetPassword(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        newPassword: newPassword,
        decryptedPrivateKey: decryptedPrivateKey,
        decryptedSignKey: decryptedSignKey);

Future<void> changePassword(
        {required String baseUrl,
        required String authToken,
        required String userIdentifier,
        required String oldPassword,
        required String newPassword,
        String? mfaToken,
        bool? mfaRecovery}) =>
    RustLib.instance.api.crateApiUserChangePassword(
        baseUrl: baseUrl,
        authToken: authToken,
        userIdentifier: userIdentifier,
        oldPassword: oldPassword,
        newPassword: newPassword,
        mfaToken: mfaToken,
        mfaRecovery: mfaRecovery);

Future<void> deleteUser(
        {required String baseUrl,
        required String authToken,
        required String freshJwt}) =>
    RustLib.instance.api.crateApiUserDeleteUser(
        baseUrl: baseUrl, authToken: authToken, freshJwt: freshJwt);

Future<void> deleteDevice(
        {required String baseUrl,
        required String authToken,
        required String freshJwt,
        required String deviceId}) =>
    RustLib.instance.api.crateApiUserDeleteDevice(
        baseUrl: baseUrl,
        authToken: authToken,
        freshJwt: freshJwt,
        deviceId: deviceId);

Future<void> updateUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String userIdentifier}) =>
    RustLib.instance.api.crateApiUserUpdateUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        userIdentifier: userIdentifier);

Future<UserPublicKeyData> userFetchPublicKey(
        {required String baseUrl,
        required String authToken,
        required String userId}) =>
    RustLib.instance.api.crateApiUserUserFetchPublicKey(
        baseUrl: baseUrl, authToken: authToken, userId: userId);

Future<String> userFetchVerifyKey(
        {required String baseUrl,
        required String authToken,
        required String userId,
        required String verifyKeyId}) =>
    RustLib.instance.api.crateApiUserUserFetchVerifyKey(
        baseUrl: baseUrl,
        authToken: authToken,
        userId: userId,
        verifyKeyId: verifyKeyId);

Future<String> userKeyRotation(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String publicDeviceKey,
        required String preUserKey}) =>
    RustLib.instance.api.crateApiUserUserKeyRotation(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        publicDeviceKey: publicDeviceKey,
        preUserKey: preUserKey);

Future<List<KeyRotationGetOut>> userPreDoneKeyRotation(
        {required String baseUrl,
        required String authToken,
        required String jwt}) =>
    RustLib.instance.api.crateApiUserUserPreDoneKeyRotation(
        baseUrl: baseUrl, authToken: authToken, jwt: jwt);

Future<KeyRotationInput> userGetDoneKeyRotationServerInput(
        {required String serverOutput}) =>
    RustLib.instance.api.crateApiUserUserGetDoneKeyRotationServerInput(
        serverOutput: serverOutput);

Future<void> userFinishKeyRotation(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String serverOutput,
        required String preGroupKey,
        required String publicKey,
        required String privateKey}) =>
    RustLib.instance.api.crateApiUserUserFinishKeyRotation(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        serverOutput: serverOutput,
        preGroupKey: preGroupKey,
        publicKey: publicKey,
        privateKey: privateKey);

Future<OtpRegister> registerRawOtp(
        {required String baseUrl,
        required String authToken,
        required String jwt}) =>
    RustLib.instance.api.crateApiUserRegisterRawOtp(
        baseUrl: baseUrl, authToken: authToken, jwt: jwt);

Future<OtpRegisterUrl> registerOtp(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String issuer,
        required String audience}) =>
    RustLib.instance.api.crateApiUserRegisterOtp(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        issuer: issuer,
        audience: audience);

Future<OtpRecoveryKeysOutput> getOtpRecoverKeys(
        {required String baseUrl,
        required String authToken,
        required String jwt}) =>
    RustLib.instance.api.crateApiUserGetOtpRecoverKeys(
        baseUrl: baseUrl, authToken: authToken, jwt: jwt);

Future<OtpRegister> resetRawOtp(
        {required String baseUrl,
        required String authToken,
        required String jwt}) =>
    RustLib.instance.api.crateApiUserResetRawOtp(
        baseUrl: baseUrl, authToken: authToken, jwt: jwt);

Future<OtpRegisterUrl> resetOtp(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String issuer,
        required String audience}) =>
    RustLib.instance.api.crateApiUserResetOtp(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        issuer: issuer,
        audience: audience);

Future<void> disableOtp(
        {required String baseUrl,
        required String authToken,
        required String jwt}) =>
    RustLib.instance.api.crateApiUserDisableOtp(
        baseUrl: baseUrl, authToken: authToken, jwt: jwt);

class Claims {
  final String aud;
  final String sub;
  final BigInt exp;
  final BigInt iat;
  final bool fresh;

  const Claims({
    required this.aud,
    required this.sub,
    required this.exp,
    required this.iat,
    required this.fresh,
  });

  @override
  int get hashCode =>
      aud.hashCode ^
      sub.hashCode ^
      exp.hashCode ^
      iat.hashCode ^
      fresh.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Claims &&
          runtimeType == other.runtimeType &&
          aud == other.aud &&
          sub == other.sub &&
          exp == other.exp &&
          iat == other.iat &&
          fresh == other.fresh;
}

class DeviceKeyData {
  final String privateKey;
  final String publicKey;
  final String signKey;
  final String verifyKey;
  final String exportedPublicKey;
  final String exportedVerifyKey;

  const DeviceKeyData({
    required this.privateKey,
    required this.publicKey,
    required this.signKey,
    required this.verifyKey,
    required this.exportedPublicKey,
    required this.exportedVerifyKey,
  });

  @override
  int get hashCode =>
      privateKey.hashCode ^
      publicKey.hashCode ^
      signKey.hashCode ^
      verifyKey.hashCode ^
      exportedPublicKey.hashCode ^
      exportedVerifyKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DeviceKeyData &&
          runtimeType == other.runtimeType &&
          privateKey == other.privateKey &&
          publicKey == other.publicKey &&
          signKey == other.signKey &&
          verifyKey == other.verifyKey &&
          exportedPublicKey == other.exportedPublicKey &&
          exportedVerifyKey == other.exportedVerifyKey;
}

class GeneratedRegisterData {
  final String identifier;
  final String password;

  const GeneratedRegisterData({
    required this.identifier,
    required this.password,
  });

  @override
  int get hashCode => identifier.hashCode ^ password.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GeneratedRegisterData &&
          runtimeType == other.runtimeType &&
          identifier == other.identifier &&
          password == other.password;
}

class KeyRotationGetOut {
  final String preGroupKeyId;
  final String newGroupKeyId;
  final String encryptedEphKeyKeyId;
  final String serverOutput;

  const KeyRotationGetOut({
    required this.preGroupKeyId,
    required this.newGroupKeyId,
    required this.encryptedEphKeyKeyId,
    required this.serverOutput,
  });

  @override
  int get hashCode =>
      preGroupKeyId.hashCode ^
      newGroupKeyId.hashCode ^
      encryptedEphKeyKeyId.hashCode ^
      serverOutput.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyRotationGetOut &&
          runtimeType == other.runtimeType &&
          preGroupKeyId == other.preGroupKeyId &&
          newGroupKeyId == other.newGroupKeyId &&
          encryptedEphKeyKeyId == other.encryptedEphKeyKeyId &&
          serverOutput == other.serverOutput;
}

class OtpRecoveryKeysOutput {
  final List<String> keys;

  const OtpRecoveryKeysOutput({
    required this.keys,
  });

  @override
  int get hashCode => keys.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OtpRecoveryKeysOutput &&
          runtimeType == other.runtimeType &&
          keys == other.keys;
}

class OtpRegister {
  final String secret;
  final String alg;
  final List<String> recover;

  const OtpRegister({
    required this.secret,
    required this.alg,
    required this.recover,
  });

  @override
  int get hashCode => secret.hashCode ^ alg.hashCode ^ recover.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OtpRegister &&
          runtimeType == other.runtimeType &&
          secret == other.secret &&
          alg == other.alg &&
          recover == other.recover;
}

class OtpRegisterUrl {
  final String url;
  final List<String> recover;

  const OtpRegisterUrl({
    required this.url,
    required this.recover,
  });

  @override
  int get hashCode => url.hashCode ^ recover.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OtpRegisterUrl &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          recover == other.recover;
}

class PreRegisterDeviceData {
  final String input;
  final String exportedPublicKey;

  const PreRegisterDeviceData({
    required this.input,
    required this.exportedPublicKey,
  });

  @override
  int get hashCode => input.hashCode ^ exportedPublicKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PreRegisterDeviceData &&
          runtimeType == other.runtimeType &&
          input == other.input &&
          exportedPublicKey == other.exportedPublicKey;
}

class RegisterDeviceData {
  final String sessionId;
  final String exportedPublicKey;

  const RegisterDeviceData({
    required this.sessionId,
    required this.exportedPublicKey,
  });

  @override
  int get hashCode => sessionId.hashCode ^ exportedPublicKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RegisterDeviceData &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          exportedPublicKey == other.exportedPublicKey;
}

class UserData {
  final String jwt;
  final String userId;
  final String deviceId;
  final String refreshToken;
  final DeviceKeyData keys;
  final List<UserKeyData> userKeys;
  final List<GroupOutDataHmacKeys> hmacKeys;

  const UserData({
    required this.jwt,
    required this.userId,
    required this.deviceId,
    required this.refreshToken,
    required this.keys,
    required this.userKeys,
    required this.hmacKeys,
  });

  @override
  int get hashCode =>
      jwt.hashCode ^
      userId.hashCode ^
      deviceId.hashCode ^
      refreshToken.hashCode ^
      keys.hashCode ^
      userKeys.hashCode ^
      hmacKeys.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserData &&
          runtimeType == other.runtimeType &&
          jwt == other.jwt &&
          userId == other.userId &&
          deviceId == other.deviceId &&
          refreshToken == other.refreshToken &&
          keys == other.keys &&
          userKeys == other.userKeys &&
          hmacKeys == other.hmacKeys;
}

class UserDeviceList {
  final String deviceId;
  final String time;
  final String deviceIdentifier;

  const UserDeviceList({
    required this.deviceId,
    required this.time,
    required this.deviceIdentifier,
  });

  @override
  int get hashCode =>
      deviceId.hashCode ^ time.hashCode ^ deviceIdentifier.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserDeviceList &&
          runtimeType == other.runtimeType &&
          deviceId == other.deviceId &&
          time == other.time &&
          deviceIdentifier == other.deviceIdentifier;
}

class UserInitServerOutput {
  final String jwt;
  final List<GroupInviteReqList> invites;

  const UserInitServerOutput({
    required this.jwt,
    required this.invites,
  });

  @override
  int get hashCode => jwt.hashCode ^ invites.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserInitServerOutput &&
          runtimeType == other.runtimeType &&
          jwt == other.jwt &&
          invites == other.invites;
}

class UserKeyData {
  final String privateKey;
  final String publicKey;
  final String groupKey;
  final String time;
  final String groupKeyId;
  final String signKey;
  final String verifyKey;
  final String exportedPublicKey;
  final String? exportedPublicKeySigKeyId;
  final String exportedVerifyKey;

  const UserKeyData({
    required this.privateKey,
    required this.publicKey,
    required this.groupKey,
    required this.time,
    required this.groupKeyId,
    required this.signKey,
    required this.verifyKey,
    required this.exportedPublicKey,
    this.exportedPublicKeySigKeyId,
    required this.exportedVerifyKey,
  });

  @override
  int get hashCode =>
      privateKey.hashCode ^
      publicKey.hashCode ^
      groupKey.hashCode ^
      time.hashCode ^
      groupKeyId.hashCode ^
      signKey.hashCode ^
      verifyKey.hashCode ^
      exportedPublicKey.hashCode ^
      exportedPublicKeySigKeyId.hashCode ^
      exportedVerifyKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserKeyData &&
          runtimeType == other.runtimeType &&
          privateKey == other.privateKey &&
          publicKey == other.publicKey &&
          groupKey == other.groupKey &&
          time == other.time &&
          groupKeyId == other.groupKeyId &&
          signKey == other.signKey &&
          verifyKey == other.verifyKey &&
          exportedPublicKey == other.exportedPublicKey &&
          exportedPublicKeySigKeyId == other.exportedPublicKeySigKeyId &&
          exportedVerifyKey == other.exportedVerifyKey;
}

class UserLoginOut {
  final String? direct;
  final String? masterKey;
  final String? authKey;

  const UserLoginOut({
    this.direct,
    this.masterKey,
    this.authKey,
  });

  @override
  int get hashCode => direct.hashCode ^ masterKey.hashCode ^ authKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserLoginOut &&
          runtimeType == other.runtimeType &&
          direct == other.direct &&
          masterKey == other.masterKey &&
          authKey == other.authKey;
}

class UserPublicKeyData {
  final String publicKey;
  final String publicKeyId;
  final String? publicKeySigKeyId;

  const UserPublicKeyData({
    required this.publicKey,
    required this.publicKeyId,
    this.publicKeySigKeyId,
  });

  @override
  int get hashCode =>
      publicKey.hashCode ^ publicKeyId.hashCode ^ publicKeySigKeyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserPublicKeyData &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          publicKeyId == other.publicKeyId &&
          publicKeySigKeyId == other.publicKeySigKeyId;
}
