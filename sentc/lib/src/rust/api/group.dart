// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'user.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

///Create input for the server api.
///
///Use this for a group and child group. For child group use the public key of the parent group!
///
Future<String> groupPrepareCreateGroup(
        {required String creatorsPublicKey,
        String? signKey,
        required String starter}) =>
    RustLib.instance.api.crateApiGroupGroupPrepareCreateGroup(
        creatorsPublicKey: creatorsPublicKey,
        signKey: signKey,
        starter: starter);

///Create a group with a request.
///
///Only the default values are sent to the server, no extra data. If extra data is required, use prepare_create
///
Future<String> groupCreateGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String creatorsPublicKey,
        String? groupAsMember,
        String? signKey,
        required String starter}) =>
    RustLib.instance.api.crateApiGroupGroupCreateGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        creatorsPublicKey: creatorsPublicKey,
        groupAsMember: groupAsMember,
        signKey: signKey,
        starter: starter);

Future<String> groupCreateChildGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String parentPublicKey,
        required String parentId,
        required int adminRank,
        String? groupAsMember,
        String? signKey,
        required String starter}) =>
    RustLib.instance.api.crateApiGroupGroupCreateChildGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        parentPublicKey: parentPublicKey,
        parentId: parentId,
        adminRank: adminRank,
        groupAsMember: groupAsMember,
        signKey: signKey,
        starter: starter);

Future<String> groupCreateConnectedGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String connectedGroupId,
        required int adminRank,
        required String parentPublicKey,
        String? groupAsMember,
        String? signKey,
        required String starter}) =>
    RustLib.instance.api.crateApiGroupGroupCreateConnectedGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        connectedGroupId: connectedGroupId,
        adminRank: adminRank,
        parentPublicKey: parentPublicKey,
        groupAsMember: groupAsMember,
        signKey: signKey,
        starter: starter);

///Get the group data without a request.
///
///Use the parent group private key when fetching child group data.
///
Future<GroupOutData> groupExtractGroupData({required String serverOutput}) =>
    RustLib.instance.api
        .crateApiGroupGroupExtractGroupData(serverOutput: serverOutput);

///Get keys from pagination.
///
///Call the group route with the last fetched key time and the last fetched key id. Get both from the key data.
///
Future<List<GroupOutDataKeys>> groupExtractGroupKeys(
        {required String serverOutput}) =>
    RustLib.instance.api
        .crateApiGroupGroupExtractGroupKeys(serverOutput: serverOutput);

Future<GroupOutData> groupGetGroupData(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupData(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

Future<List<GroupOutDataKeys>> groupGetGroupKeys(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String lastFetchedTime,
        required String lastFetchedKeyId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupKeys(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        lastFetchedTime: lastFetchedTime,
        lastFetchedKeyId: lastFetchedKeyId,
        groupAsMember: groupAsMember);

Future<GroupOutDataKeys> groupGetGroupKey(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String keyId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupKey(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        keyId: keyId,
        groupAsMember: groupAsMember);

Future<GroupKeyData> groupDecryptKey(
        {required String privateKey,
        required String serverKeyData,
        String? verifyKey}) =>
    RustLib.instance.api.crateApiGroupGroupDecryptKey(
        privateKey: privateKey,
        serverKeyData: serverKeyData,
        verifyKey: verifyKey);

Future<String> groupDecryptHmacKey(
        {required String groupKey, required String serverKeyData}) =>
    RustLib.instance.api.crateApiGroupGroupDecryptHmacKey(
        groupKey: groupKey, serverKeyData: serverKeyData);

Future<String> groupDecryptSortableKey(
        {required String groupKey, required String serverKeyData}) =>
    RustLib.instance.api.crateApiGroupGroupDecryptSortableKey(
        groupKey: groupKey, serverKeyData: serverKeyData);

Future<List<GroupUserListItem>> groupGetMember(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String lastFetchedTime,
        required String lastFetchedId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetMember(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        lastFetchedTime: lastFetchedTime,
        lastFetchedId: lastFetchedId,
        groupAsMember: groupAsMember);

Future<GroupDataCheckUpdateServerOutput> groupGetGroupUpdates(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupUpdates(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

Future<List<GroupChildrenList>> groupGetAllFirstLevelChildren(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetAllFirstLevelChildren(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupAsMember: groupAsMember);

Future<List<ListGroups>> groupGetGroupsForUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupId}) =>
    RustLib.instance.api.crateApiGroupGroupGetGroupsForUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupId: groupId);

///Prepare all group keys for a new member.
///
///Use the group keys from get group data or get group keys fn as a string array
///
Future<String> groupPrepareKeysForNewMember(
        {required String userPublicKey,
        required String groupKeys,
        required int keyCount,
        int? rank,
        required int adminRank}) =>
    RustLib.instance.api.crateApiGroupGroupPrepareKeysForNewMember(
        userPublicKey: userPublicKey,
        groupKeys: groupKeys,
        keyCount: keyCount,
        rank: rank,
        adminRank: adminRank);

Future<String> groupInviteUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        required int keyCount,
        int? rank,
        required int adminRank,
        required bool autoInvite,
        required bool groupInvite,
        required bool reInvite,
        required String userPublicKey,
        required String groupKeys,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupInviteUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        keyCount: keyCount,
        rank: rank,
        adminRank: adminRank,
        autoInvite: autoInvite,
        groupInvite: groupInvite,
        reInvite: reInvite,
        userPublicKey: userPublicKey,
        groupKeys: groupKeys,
        groupAsMember: groupAsMember);

Future<void> groupInviteUserSession(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required bool autoInvite,
        required String sessionId,
        required String userPublicKey,
        required String groupKeys,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupInviteUserSession(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        autoInvite: autoInvite,
        sessionId: sessionId,
        userPublicKey: userPublicKey,
        groupKeys: groupKeys,
        groupAsMember: groupAsMember);

Future<List<GroupInviteReqList>> groupGetInvitesForUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetInvitesForUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<void> groupAcceptInvite(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupAcceptInvite(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<void> groupRejectInvite(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupRejectInvite(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<List<GroupInviteReqList>> groupGetSentJoinReqUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetSentJoinReqUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupAsMember: groupAsMember);

Future<List<GroupInviteReqList>> groupGetSentJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String lastFetchedTime,
        required String lastFetchedGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetSentJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        lastFetchedTime: lastFetchedTime,
        lastFetchedGroupId: lastFetchedGroupId,
        groupAsMember: groupAsMember);

Future<void> groupDeleteSentJoinReqUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String joinReqGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupDeleteSentJoinReqUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        joinReqGroupId: joinReqGroupId,
        groupAsMember: groupAsMember);

Future<void> groupDeleteSentJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String joinReqGroupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupDeleteSentJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        joinReqGroupId: joinReqGroupId,
        groupAsMember: groupAsMember);

Future<void> groupJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String groupId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupId: groupId,
        groupAsMember: groupAsMember);

Future<List<GroupJoinReqList>> groupGetJoinReqs(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String lastFetchedTime,
        required String lastFetchedId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupGetJoinReqs(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        lastFetchedTime: lastFetchedTime,
        lastFetchedId: lastFetchedId,
        groupAsMember: groupAsMember);

Future<void> groupRejectJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        required String rejectedUserId,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupRejectJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        rejectedUserId: rejectedUserId,
        groupAsMember: groupAsMember);

Future<String> groupAcceptJoinReq(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        required int keyCount,
        int? rank,
        required int adminRank,
        required String userPublicKey,
        required String groupKeys,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupAcceptJoinReq(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        keyCount: keyCount,
        rank: rank,
        adminRank: adminRank,
        userPublicKey: userPublicKey,
        groupKeys: groupKeys,
        groupAsMember: groupAsMember);

Future<void> groupJoinUserSession(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String sessionId,
        required String userPublicKey,
        required String groupKeys,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupJoinUserSession(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        sessionId: sessionId,
        userPublicKey: userPublicKey,
        groupKeys: groupKeys,
        groupAsMember: groupAsMember);

Future<void> groupStopGroupInvites(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupStopGroupInvites(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> leaveGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupLeaveGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

Future<String> groupPrepareKeyRotation(
        {required String preGroupKey,
        required String publicKey,
        String? signKey,
        required String starter}) =>
    RustLib.instance.api.crateApiGroupGroupPrepareKeyRotation(
        preGroupKey: preGroupKey,
        publicKey: publicKey,
        signKey: signKey,
        starter: starter);

Future<String> groupDoneKeyRotation(
        {required String privateKey,
        required String publicKey,
        required String preGroupKey,
        required String serverOutput}) =>
    RustLib.instance.api.crateApiGroupGroupDoneKeyRotation(
        privateKey: privateKey,
        publicKey: publicKey,
        preGroupKey: preGroupKey,
        serverOutput: serverOutput);

Future<String> groupKeyRotation(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String publicKey,
        required String preGroupKey,
        String? signKey,
        required String starter,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupKeyRotation(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        publicKey: publicKey,
        preGroupKey: preGroupKey,
        signKey: signKey,
        starter: starter,
        groupAsMember: groupAsMember);

Future<List<KeyRotationGetOut>> groupPreDoneKeyRotation(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupPreDoneKeyRotation(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        groupAsMember: groupAsMember);

KeyRotationInput groupGetDoneKeyRotationServerInput(
        {required String serverOutput}) =>
    RustLib.instance.api.crateApiGroupGroupGetDoneKeyRotationServerInput(
        serverOutput: serverOutput);

Future<void> groupFinishKeyRotation(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String serverOutput,
        required String preGroupKey,
        required String publicKey,
        required String privateKey,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupFinishKeyRotation(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        serverOutput: serverOutput,
        preGroupKey: preGroupKey,
        publicKey: publicKey,
        privateKey: privateKey,
        groupAsMember: groupAsMember);

String groupPrepareUpdateRank(
        {required String userId, required int rank, required int adminRank}) =>
    RustLib.instance.api.crateApiGroupGroupPrepareUpdateRank(
        userId: userId, rank: rank, adminRank: adminRank);

Future<void> groupUpdateRank(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        required int rank,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupUpdateRank(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        rank: rank,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> groupKickUser(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required String userId,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupKickUser(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        userId: userId,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<void> groupDeleteGroup(
        {required String baseUrl,
        required String authToken,
        required String jwt,
        required String id,
        required int adminRank,
        String? groupAsMember}) =>
    RustLib.instance.api.crateApiGroupGroupDeleteGroup(
        baseUrl: baseUrl,
        authToken: authToken,
        jwt: jwt,
        id: id,
        adminRank: adminRank,
        groupAsMember: groupAsMember);

Future<GroupPublicKeyData> groupGetPublicKeyData(
        {required String baseUrl,
        required String authToken,
        required String id}) =>
    RustLib.instance.api.crateApiGroupGroupGetPublicKeyData(
        baseUrl: baseUrl, authToken: authToken, id: id);

class GroupChildrenList {
  final String groupId;
  final String time;
  final String? parent;

  const GroupChildrenList({
    required this.groupId,
    required this.time,
    this.parent,
  });

  @override
  int get hashCode => groupId.hashCode ^ time.hashCode ^ parent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupChildrenList &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          time == other.time &&
          parent == other.parent;
}

class GroupDataCheckUpdateServerOutput {
  final bool keyUpdate;
  final int rank;

  const GroupDataCheckUpdateServerOutput({
    required this.keyUpdate,
    required this.rank,
  });

  @override
  int get hashCode => keyUpdate.hashCode ^ rank.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupDataCheckUpdateServerOutput &&
          runtimeType == other.runtimeType &&
          keyUpdate == other.keyUpdate &&
          rank == other.rank;
}

class GroupInviteReqList {
  final String groupId;
  final String time;

  const GroupInviteReqList({
    required this.groupId,
    required this.time,
  });

  @override
  int get hashCode => groupId.hashCode ^ time.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupInviteReqList &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          time == other.time;
}

class GroupJoinReqList {
  final String userId;
  final String time;
  final int userType;

  const GroupJoinReqList({
    required this.userId,
    required this.time,
    required this.userType,
  });

  @override
  int get hashCode => userId.hashCode ^ time.hashCode ^ userType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupJoinReqList &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          time == other.time &&
          userType == other.userType;
}

class GroupKeyData {
  final String privateGroupKey;
  final String publicGroupKey;
  final String exportedPublicKey;
  final String groupKey;
  final String time;
  final String groupKeyId;

  const GroupKeyData({
    required this.privateGroupKey,
    required this.publicGroupKey,
    required this.exportedPublicKey,
    required this.groupKey,
    required this.time,
    required this.groupKeyId,
  });

  @override
  int get hashCode =>
      privateGroupKey.hashCode ^
      publicGroupKey.hashCode ^
      exportedPublicKey.hashCode ^
      groupKey.hashCode ^
      time.hashCode ^
      groupKeyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupKeyData &&
          runtimeType == other.runtimeType &&
          privateGroupKey == other.privateGroupKey &&
          publicGroupKey == other.publicGroupKey &&
          exportedPublicKey == other.exportedPublicKey &&
          groupKey == other.groupKey &&
          time == other.time &&
          groupKeyId == other.groupKeyId;
}

class GroupOutData {
  final String groupId;
  final String? parentGroupId;
  final int rank;
  final bool keyUpdate;
  final String createdTime;
  final String joinedTime;
  final List<GroupOutDataKeys> keys;
  final List<GroupOutDataHmacKeys> hmacKeys;
  final List<GroupOutDataSortableKeys> sortableKeys;
  final String? accessByGroupAsMember;
  final String? accessByParentGroup;
  final bool isConnectedGroup;

  const GroupOutData({
    required this.groupId,
    this.parentGroupId,
    required this.rank,
    required this.keyUpdate,
    required this.createdTime,
    required this.joinedTime,
    required this.keys,
    required this.hmacKeys,
    required this.sortableKeys,
    this.accessByGroupAsMember,
    this.accessByParentGroup,
    required this.isConnectedGroup,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      parentGroupId.hashCode ^
      rank.hashCode ^
      keyUpdate.hashCode ^
      createdTime.hashCode ^
      joinedTime.hashCode ^
      keys.hashCode ^
      hmacKeys.hashCode ^
      sortableKeys.hashCode ^
      accessByGroupAsMember.hashCode ^
      accessByParentGroup.hashCode ^
      isConnectedGroup.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupOutData &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          parentGroupId == other.parentGroupId &&
          rank == other.rank &&
          keyUpdate == other.keyUpdate &&
          createdTime == other.createdTime &&
          joinedTime == other.joinedTime &&
          keys == other.keys &&
          hmacKeys == other.hmacKeys &&
          sortableKeys == other.sortableKeys &&
          accessByGroupAsMember == other.accessByGroupAsMember &&
          accessByParentGroup == other.accessByParentGroup &&
          isConnectedGroup == other.isConnectedGroup;
}

class GroupOutDataHmacKeys {
  final String groupKeyId;
  final String keyData;

  const GroupOutDataHmacKeys({
    required this.groupKeyId,
    required this.keyData,
  });

  @override
  int get hashCode => groupKeyId.hashCode ^ keyData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupOutDataHmacKeys &&
          runtimeType == other.runtimeType &&
          groupKeyId == other.groupKeyId &&
          keyData == other.keyData;
}

class GroupOutDataKeys {
  final String privateKeyId;
  final String keyData;
  final String? signedByUserId;
  final String? signedByUserSignKeyId;

  const GroupOutDataKeys({
    required this.privateKeyId,
    required this.keyData,
    this.signedByUserId,
    this.signedByUserSignKeyId,
  });

  @override
  int get hashCode =>
      privateKeyId.hashCode ^
      keyData.hashCode ^
      signedByUserId.hashCode ^
      signedByUserSignKeyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupOutDataKeys &&
          runtimeType == other.runtimeType &&
          privateKeyId == other.privateKeyId &&
          keyData == other.keyData &&
          signedByUserId == other.signedByUserId &&
          signedByUserSignKeyId == other.signedByUserSignKeyId;
}

class GroupOutDataSortableKeys {
  final String groupKeyId;
  final String keyData;

  const GroupOutDataSortableKeys({
    required this.groupKeyId,
    required this.keyData,
  });

  @override
  int get hashCode => groupKeyId.hashCode ^ keyData.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupOutDataSortableKeys &&
          runtimeType == other.runtimeType &&
          groupKeyId == other.groupKeyId &&
          keyData == other.keyData;
}

class GroupPublicKeyData {
  final String publicKey;
  final String publicKeyId;

  const GroupPublicKeyData({
    required this.publicKey,
    required this.publicKeyId,
  });

  @override
  int get hashCode => publicKey.hashCode ^ publicKeyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupPublicKeyData &&
          runtimeType == other.runtimeType &&
          publicKey == other.publicKey &&
          publicKeyId == other.publicKeyId;
}

class GroupUserListItem {
  final String userId;
  final int rank;
  final String joinedTime;
  final int userType;

  const GroupUserListItem({
    required this.userId,
    required this.rank,
    required this.joinedTime,
    required this.userType,
  });

  @override
  int get hashCode =>
      userId.hashCode ^ rank.hashCode ^ joinedTime.hashCode ^ userType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupUserListItem &&
          runtimeType == other.runtimeType &&
          userId == other.userId &&
          rank == other.rank &&
          joinedTime == other.joinedTime &&
          userType == other.userType;
}

class KeyRotationInput {
  final String? error;
  final String encryptedEphemeralKeyByGroupKeyAndPublicKey;
  final String encryptedGroupKeyByEphemeral;
  final String ephemeralAlg;
  final String encryptedEphKeyKeyId;
  final String previousGroupKeyId;
  final String time;
  final String newGroupKeyId;

  const KeyRotationInput({
    this.error,
    required this.encryptedEphemeralKeyByGroupKeyAndPublicKey,
    required this.encryptedGroupKeyByEphemeral,
    required this.ephemeralAlg,
    required this.encryptedEphKeyKeyId,
    required this.previousGroupKeyId,
    required this.time,
    required this.newGroupKeyId,
  });

  @override
  int get hashCode =>
      error.hashCode ^
      encryptedEphemeralKeyByGroupKeyAndPublicKey.hashCode ^
      encryptedGroupKeyByEphemeral.hashCode ^
      ephemeralAlg.hashCode ^
      encryptedEphKeyKeyId.hashCode ^
      previousGroupKeyId.hashCode ^
      time.hashCode ^
      newGroupKeyId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyRotationInput &&
          runtimeType == other.runtimeType &&
          error == other.error &&
          encryptedEphemeralKeyByGroupKeyAndPublicKey ==
              other.encryptedEphemeralKeyByGroupKeyAndPublicKey &&
          encryptedGroupKeyByEphemeral == other.encryptedGroupKeyByEphemeral &&
          ephemeralAlg == other.ephemeralAlg &&
          encryptedEphKeyKeyId == other.encryptedEphKeyKeyId &&
          previousGroupKeyId == other.previousGroupKeyId &&
          time == other.time &&
          newGroupKeyId == other.newGroupKeyId;
}

class ListGroups {
  final String groupId;
  final String time;
  final String joinedTime;
  final int rank;
  final String? parent;

  const ListGroups({
    required this.groupId,
    required this.time,
    required this.joinedTime,
    required this.rank,
    this.parent,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      time.hashCode ^
      joinedTime.hashCode ^
      rank.hashCode ^
      parent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListGroups &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          time == other.time &&
          joinedTime == other.joinedTime &&
          rank == other.rank &&
          parent == other.parent;
}
